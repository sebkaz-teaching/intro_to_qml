[
  {
    "objectID": "lectures/wyklad5.html",
    "href": "lectures/wyklad5.html",
    "title": "Kwantowe uczenie maszynowe",
    "section": "",
    "text": "Parametryzowany Obwód Kwantowy (PQC) to typ obwodu kwantowego, który wykorzystuje parametry klasyczne. Te obwody są kluczowym elementem wariacyjnych algorytmów kwantowych, które są klasą algorytmów kwantowych wykorzystujących klasyczne techniki optymalizacji do znalezienia optymalnych parametrów dla obwodu kwantowego.\nStruktura PQC jest zazwyczaj stała i składa się z serii bramek kwantowych. Parametry tych bramek, jednak, mogą być dostosowane. Pozwala to na dostrojenie obwodu do rozwiązania konkretnego problemu. Parametry są zazwyczaj optymalizowane za pomocą klasycznego algorytmu optymalizacji, z celem znalezienia zestawu parametrów, które minimalizują pewną funkcję kosztu.\nPQC są szczególnie przydatne w kwantowym uczeniu maszynowym, gdzie mogą być używane do konstrukcji kwantowych sieci neuronowych. Te sieci mogą być trenowane w podobny sposób do klasycznych sieci neuronowych, poprzez dostosowywanie parametrów bramek kwantowych do minimalizacji funkcji kosztu.\nPodsumowując, Parametryzowane Obwody Kwantowe są potężnym narzędziem w dziedzinie informatyki kwantowej, umożliwiając integrację klasycznych technik optymalizacji z obliczeniami kwantowymi. Są kluczowym elementem wielu algorytmów kwantowych i mają szeroki zakres zastosowań, od kwantowego uczenia maszynowego po chemię kwantową.\nOto prosty przykład PQC w Pythonie za pomocą biblioteki Qiskit:\nfrom qiskit import QuantumCircuit\n\n# Utwórz Parametryzowany Obwód Kwantowy z 2 kubitami\nqc = QuantumCircuit(2)\n\n# Dodaj parametryzowaną bramkę\nfrom qiskit.circuit import Parameter\ntheta = Parameter('θ')\nqc.rx(theta, 0)\n\n# Wyświetl obwód\nprint(qc)\nW tym przykładzie tworzymy obwód kwantowy z dwoma kubitami i dodajemy parametryzowaną bramkę RX do pierwszego kubitu. Parametr ‘θ’ może być dostosowany do zmiany zachowania obwodu.\n//TODO dodac info o VQE"
  },
  {
    "objectID": "lectures/wyklad5.html#parameterized-quantum-circuit",
    "href": "lectures/wyklad5.html#parameterized-quantum-circuit",
    "title": "Kwantowe uczenie maszynowe",
    "section": "",
    "text": "Parametryzowany Obwód Kwantowy (PQC) to typ obwodu kwantowego, który wykorzystuje parametry klasyczne. Te obwody są kluczowym elementem wariacyjnych algorytmów kwantowych, które są klasą algorytmów kwantowych wykorzystujących klasyczne techniki optymalizacji do znalezienia optymalnych parametrów dla obwodu kwantowego.\nStruktura PQC jest zazwyczaj stała i składa się z serii bramek kwantowych. Parametry tych bramek, jednak, mogą być dostosowane. Pozwala to na dostrojenie obwodu do rozwiązania konkretnego problemu. Parametry są zazwyczaj optymalizowane za pomocą klasycznego algorytmu optymalizacji, z celem znalezienia zestawu parametrów, które minimalizują pewną funkcję kosztu.\nPQC są szczególnie przydatne w kwantowym uczeniu maszynowym, gdzie mogą być używane do konstrukcji kwantowych sieci neuronowych. Te sieci mogą być trenowane w podobny sposób do klasycznych sieci neuronowych, poprzez dostosowywanie parametrów bramek kwantowych do minimalizacji funkcji kosztu.\nPodsumowując, Parametryzowane Obwody Kwantowe są potężnym narzędziem w dziedzinie informatyki kwantowej, umożliwiając integrację klasycznych technik optymalizacji z obliczeniami kwantowymi. Są kluczowym elementem wielu algorytmów kwantowych i mają szeroki zakres zastosowań, od kwantowego uczenia maszynowego po chemię kwantową.\nOto prosty przykład PQC w Pythonie za pomocą biblioteki Qiskit:\nfrom qiskit import QuantumCircuit\n\n# Utwórz Parametryzowany Obwód Kwantowy z 2 kubitami\nqc = QuantumCircuit(2)\n\n# Dodaj parametryzowaną bramkę\nfrom qiskit.circuit import Parameter\ntheta = Parameter('θ')\nqc.rx(theta, 0)\n\n# Wyświetl obwód\nprint(qc)\nW tym przykładzie tworzymy obwód kwantowy z dwoma kubitami i dodajemy parametryzowaną bramkę RX do pierwszego kubitu. Parametr ‘θ’ może być dostosowany do zmiany zachowania obwodu.\n//TODO dodac info o VQE"
  },
  {
    "objectID": "lectures/wyklad1.html",
    "href": "lectures/wyklad1.html",
    "title": "Komputery klasyczne i kwantowe",
    "section": "",
    "text": "Nature isn’t classical, dammit, and if you want to make a simulation of Nature, you’d better make it quantum mechanical, and by golly it’s a wonderful problem because it doesn’t look so easy. Richard Feynman\nQuntum Machine Learning\nCo oznacza termin kwantowe uczenie maszynowe?\nUczenie maszynowe (ale również i uczenie głębokie) to nauka i ,,sztuka’’ opisująca jak sprawić by komputery mogły ,,uczyć się’’ na podstawie danych, tak by rozwiązać problemy, których typowe programowanie nie miałoby sensu (lub byłoby zbyt skomplikowane). Więcej na ten temat znajdziesz w książce\nObliczenia kwantowe opisują przetwarzenie informacji na urządzeniach pracujących zgodnie z zasadami mechaniki kwantowej.\nOba kierunki są istotne w procesie przetwarzania danych obecnie i w niedalekiej przyszłości. Dlatego naturalnym pytaniem jest jak je ze sobą połączyć?\nQML to realizowanie metod uczenia maszynowego, które mogą być wykonywane na komputerach kwantowych.\nKwantowe uczenie maszynowe możemy określić jako uczenie maszynowe realizowane na komputerach kwantowych. Zasadniczym jest pytanie na ile i czy wogóle komputery kwantowe mogą poprawić jakość modeli uczenia maszynowego i czy pozwalają zrealizować coś więcej niż wykorzystanie klasycznych komputerów.\nOdpowiedź To zależy:"
  },
  {
    "objectID": "lectures/wyklad1.html#sztuczna-inteligencja",
    "href": "lectures/wyklad1.html#sztuczna-inteligencja",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Sztuczna inteligencja",
    "text": "Sztuczna inteligencja\n\nHistoria AI sięga 1950 roku (A. Turing). Rozwój technologii związanych z danymi ustrukturyzowanymi i nieustrukturyzowanymi realizowany np. w:\n\nrozpoznawanie i tworzenie ,,mowy’’\n,,rozumienie’’ obrazów i filmów\nrozgrywanie gier\nrekomendacje\nsystemy diagnostyczne\nplanowanie\npodejmowanie decyzji\nbooty, agenci …\n\nZadania te realizowane są w oparciu o uczenie maszynowe (Machine Learning) i głębokie sieci neuronowe (Deep Learning).\nDlaczego tak chętnie używamy:\n\nWykładniczy wzrost ilości (treningowych) danych dostępnych w social mediach, internecie, aplikacjach mobilnych, IoT.\nWzrost możliwości i spadek ceny (kosztów) jakości sprzętu komputerowego - co-procesory GPU, TPU, …\nOprogramowanie Open Source\nPrzewaga konkurencyjna przedsiębiorstw z AI na firmami bez AI\n\n\n\nUwaga! Zakładam, że znasz podstawowe pojęcia związane z uczeniem maszynowym i głębokim.\n\nUczenie maszynowe (ang. Machine Learning) można podzielić na trzy główne kategorie:\n\nUczenie nadzorowane (ang. supervised learning) - posiadając oznaczone dane \\((x_i, y_i)\\) szukamy funkcji \\(f(x_i) = y_i\\) tak by uogólnić ją na nowe dane. Np. dać kredyt, czy na obrazie jest kot albo pies itp.\nUczenie nienadzorowane (ang. unsupervised learning) - posiadając dane \\((x_i)\\) szukamy struktury w danych.\nUczenie przez wzmacnianie (ang. reinforcement learning) - agent uczy się na podstawie nagród i kar.\nUczenie transferowe () - to technika w uczeniu maszynowym, która polega na wykorzystywaniu wiedzy lub umiejętności nabytej w jednym zadaniu do rozwiązania innych zadań. Uczenie transferowe jest szeroko stosowane w praktyce. Na przykład, model językowy, który nauczył się rozpoznawać język naturalny w jednym zadaniu, może być używany do polepszania innych zadań, takich jak tłumaczenie maszynowe, analiza sentymentu czy rozpoznawanie tekstu pisanego.\nUczenie pół-nadzorowane to podejście, które wykorzystuje zarówno dane oznaczone (gdzie mamy etykiety klas) jak i dane nieoznaczone (gdzie brakuje etykiet) do trenowania modelu."
  },
  {
    "objectID": "lectures/wyklad1.html#klasyczne-komputery",
    "href": "lectures/wyklad1.html#klasyczne-komputery",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Klasyczne komputery",
    "text": "Klasyczne komputery\nKomputer to fizyczne urządzenie bazujące na obwodach elektronicznych (electronic circuits), które służy do przetwarzania informacji.\n\nAlgorytmy (programy komputerowe - software) to sekwencje logicznych i matematycznych kroków, które określają sposób rozwiązywania problemu lub wykonywania obliczeń przy użyciu komputera. Są to abstrakcyjne przepisy, które programy komputerowe implementują, aby przetwarzać dane i osiągnąć konkretne cele.\n\nMoore’s law An observation that the number of transistors on microchip roughly doubles every two years, whereas its cost is halved over that same timeframe. The growth of microprocessors is exponential\n\nZwiększenie szybkości działania oraz pojemności klasycznych komputerów co dwa lata zmniejszając przy tym koszty. W ostatnich latach obserwujemy, że to prawo zaczyna osiągać swoje ograniczenia, a dalszy wzrost mocy komputerów może być trudniejszy do osiągnięcia w tradycyjny sposób.\n\nFizyczne (klasyczne) ograniczenia dla procesorów\n\nRozmiary tranzystora \\(\\sim\\) rozmiary atomów - lata 90’te \\(500 nm\\) obecnie \\(14 nm\\) i \\(7 nm\\).\nPrędkość światła \\(\\sim\\) max. prędkość przesyłu informacji.\nWysoki koszt wytwarzania (kierunek układów wieloprocesorowych)\nW miarę jak tranzystory stają się coraz mniejsze, zbliżają się do skali wymiarów atomów, co prowadzi do pojawienia się efektów kwantowych, które mogą wpływać na ich zachowanie. Rozwój komputerów kwantowych stanowi próbę obejścia tych ograniczeń.\nWysoki pobór prądu\nW miarę jak komputery stają się bardziej zaawansowane i wykonują bardziej intensywne obliczenia, generują znaczne ilości ciepła. To może prowadzić do problemów z chłodzeniem i wpływać na wydajność. Ograniczenia te wymagają innowacji w zakresie chłodzenia komputerów.\nProdukcja mikroprocesorów i układów scalonych wymaga rzadkich materiałów i zasobów, co może stanowić ograniczenie w kontekście zrównoważonego rozwoju technologii komputerowych.\n\nDla większości praktycznych zastosowań, opis makroskopowy oraz klasyczne teorie są wystarczające do opisu własności prądu w obwodach elektrycznych. Jednakże, gdy naszym celem jest realizacja obliczeń wykorzystujących własności mikroskopowych obiektów, okazuje się, że klasyczny opis przestaje być wystarczający. W takich przypadkach, musimy zwrócić się ku mechanice kwantowej, która jest najlepiej przetestowanym i stosowanym opisem mikroświata, jaki znamy. Komputer, który wykonuje obliczenia zgodnie z zasadami mechaniki kwantowej, nazywamy komputerem kwantowym. Dzięki swojej zdolności do wykorzystania zjawisk kwantowych, takich jak superpozycja i splątanie, komputery kwantowe mogą rozwiązywać problemy, które byłyby trudne lub niemożliwe do rozwiązania za pomocą klasycznych komputerów. Są one obiecującą technologią, która otwiera nowe możliwości w dziedzinie obliczeń i nauki."
  },
  {
    "objectID": "lectures/wyklad1.html#obliczenia-kwantowe",
    "href": "lectures/wyklad1.html#obliczenia-kwantowe",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Obliczenia kwantowe",
    "text": "Obliczenia kwantowe\n\nFilm wprowadzający: link\n\nTermin Mechanika Kwantowa (MK) jest używany zamiennie z terminem Teoria Kwantowa. Istnieją jednak teorie kwantowe, takie jak Kwantowa Teoria Pola, które wykraczają poza zakres mechanicznej kwantowej.\nMechanika Kwantowa przewiduje wyniki eksperymentów przeprowadzanych na układach kwantowych, tj. mikroskopowych obiektach fizycznych, dla których fizyka klasyczna nie jest wystarczająca. Przykładem może być atom wodoru. Mechanika Kwantowa opisuje zachowanie obiektów takich jak fotony, elektrony lub kwantowe bity (qubity).\nWarto zaznaczyć, że Mechanika Kwantowa jest fundamentem, na którym opiera się wiele innych teorii i dziedzin fizyki. Jest to jedna z najbardziej udowodnionych i sprawdzonych teorii w historii nauki i stanowi podstawę dla zrozumienia mikroświata.\n\nNa naszym wykładzie nie będą interesować nas własności fizyczne kubitów a ograniczymy się do znajomości ich pewnych, abstrakcyjnych stanów w jakich mogą się one znajdować. Stany te numerowane będą liczbami naturalnymi.\n\nFizyka klasyczna jest zazwyczaj rozumiana jako graniczny przypadek Mechaniki Kwantowej (MK). Niemniej jednak, fizycy często starają się oddzielać te dwie dziedziny i stosować odpowiednią teorię do odpowiedniego problemu. Na przykład, w konstrukcji mostów korzysta się z fizyki klasycznej, a nie MK.\nWarto zaznaczyć, że wyniki MK są probabilistyczne, co często prowadzi do błędnego przekonania, że MK jest teorią statystyczną. Niemniej jednak, nie jest to prawda. Mechanikę Kwantową można raczej uznać za uogólnienie klasycznej definicji prawdopodobieństwa.\n\nHistoria MK\nPoczątek Mechaniki Kwantowej związane są z pracami Maxa Plancka (1900) i Alberta Einsteina (1905), którzy wprowadzili pojęcie kwantu - czyli najmniejszej porcji energii. Dalszy rozwój Mechaniki Kwantowej związany jest z badaniami takich naukowców jak Niels Bohr, Erwin Schrödinger, Louis de Broglie, Heisenberg, Dirac, Feynman i wielu innych. Pozostałe informacje możesz znaleźć w artykule o obliczeniach kwantowych\n\nInformatyków (najczęściej) nie interesuje, w jaki sposób właściwości fizyczne układów są Informatycy, najczęściej, nie muszą interesować się tym, w jaki sposób właściwości fizyczne układów są wykorzystywane do przechowywania informacji w komputerze klasycznym. Podobnie, informatycy (oraz analitycy danych) nie muszą się zastanawiać nad fizycznym mechanizmem, za pomocą którego informacja kwantowa jest realizowana w komputerze kwantowym. Czy prowadząc samochód zastanawiasz się, jak dokładnie działają wszystkie jego części? A pisząc kod modelu, zastanawiasz się, jak został on zaimplementowany w bibliotece?” Ta wersja jest bardziej klarowna i wyraża ideę, że informatycy często nie muszą zagłębiać się w szczegóły fizycznej realizacji, skupiając się na wydajnym wykorzystaniu technologii komputerowych.\n\n\n\nHistoria obliczeń kwantowych\n\n1936 Alan Turing opublikował pracę On Computable Numbers, która stanowiła istotny krok w kierunku teoretycznych podstaw obliczeń (Hilbert Problems) - universal computing machine local\n1976 Roman S. Ingarden - Quantum Information Theory Roman S. Ingarden wprowadził pojęcie teorii informacji kwantowej, co miało kluczowe znaczenie dla rozwoju komputerów kwantowych.\n1980 Paul Benioff - Paul Benioff przedstawił teoretyczną koncepcję komputerów kwantowych jako fizycznych systemów, otwierając drzwi do praktycznych implementacji.\n1981 Richard Feynman - zwrócił uwagę na to, że klasyczne komputery nie są w stanie efektywnie symulować procesów kwantowych.\n1985 David Deutsch opracował pierwszy opis kwantowej maszyny Turinga i algorytmów przeznaczonych do uruchamiania na komputerach kwantowych, w tym bramek kwantowych.\n1994 Peter Shor opracował algorytm faktoryzacji liczb w czasie wielomianowym, co miało znaczenie dla kryptografii i bezpieczeństwa informacji.\n1996 Lov Grover - Lov Grover stworzył algorytm Grover’a, który okazał się wyjątkowo efektywny w przeszukiwaniu baz danych.\n2000 Pierwszy komputer kwantowy (5 qubitów) oparty na nuklearnym rezonansie magnetycznym został zbudowany, co stanowiło ważny krok w rozwoju fizycznych platform komputerów kwantowych.\n2001 Demonstracja algorytmu Shora potwierdziła praktyczność i znaczenie algorytmów kwantowych.\n2007 Firma D-Wave dokonała pierwszej sprzedaży komercyjnego komputera kwantowego, co miało wpływ na rozwój technologii komputerów kwantowych w sektorze prywatnym.\nFirma IBM dokonała znaczącego przełomu, pokazując, że klasyczne superkomputery nie są w stanie efektywnie symulować systemów zawierających więcej niż 56 kubitów, co jest znane jako “quantum supremacy.”\n23 października 2019: Google ogłosił uzyskanie quantum supremacy na 53 kubitach, co miało duże znaczenie dla przyszłości obliczeń kwantowych.\nIBM osiągnął znaczący postęp w dziedzinie próbkowania, co miało wpływ na konkurencję w dziedzinie komputerów kwantowych.\n2020 Zespół Jian-Wei Pana z University of Science and Technology of China dokonał przełomu, osiągając 76 fotonowych kubitów na komputerze Jiuzhang.\n2021 Kontynuując swoje badania, University of Science and Technology of China osiągnęło kolejne osiągnięcia w dziedzinie obliczeń kwantowych.\n2022 Firma Xanadu dokonała znaczących postępów w dziedzinie technologii komputerów kwantowych.\n\nOd około 1990 roku fizycy i informatycy pracują nad fizyczną realizacją komputerów kwantowych. Jednym z popularnych modeli obliczeń na komputerach kwantowych jest model oparty na kwantowych obwodach (quantum circuit), który wykorzystuje qubity zamiast klasycznych bitów. Podobnie jak w przypadku obwodów klasycznych, w modelu kwantowym definiuje się bramki kwantowe (quantum gates), które pozwalają na wykonywanie operacji na qubitach.\nFizyczna konstrukcja komputera kwantowego, a właściwie qubitu, jest zadaniem nietrywialnym, ponieważ wymaga manipulacji bardzo małym układem, który jest zazwyczaj wyjątkowo wrażliwy na wszelkie oddziaływania z otoczeniem, co nazywa się dekoherencją.\n\n\n\nDlaczego chcemy używać komputerów kwantowych?\n\nKwantowa Złożoność (Quantum Complexity)\nNowy paradygmat wykorzystuje unikalne cechy interferencji, superpozycji i splątania w celu wykonywania obliczeń. Obecnie realizowany jest w trzech modelach:\n\nQuantum Circuits (Obwody Kwantowe) - oparty na modelu bramkowym, w tym QAOA, VQA, oraz metody hybrydowe.\nAdiabatyczne Obliczenia Kwantowe (D-Wave) - polegające na minimalizacji energii, z wykorzystaniem QUBO i analogii do modelu Isinga.\nTopologiczne Komputery Kwantowe - oparte na topologicznych kubitach.\n\nProblemy, które uważamy za trudne do rozwiązania klasycznie, takie jak optymalizacja, stają się łatwiejsze dla komputerów kwantowych. Przykładem jest faktoryzacja liczb. Klasyczne komputery nie są w stanie efektywnie symulować działania kwantowych komputerów. Koszt najlepszych symulatorów rośnie wykładniczo wraz z liczbą kubitów. Możliwości komputerów kwantowych są potencjalnie ogromne, ale obecnie istnieją pewne ograniczenia link. Kwantowy komputer może być używany do efektywnej symulacji niemal dowolnego procesu fizycznego zachodzącego w przyrodzie, choć nie zawsze jesteśmy pewni, czy taka symulacja jest możliwa.\nPodstawowym faktem przewagi komputerów kwantowych nad klasycznymi jest tzw. parallelizm. Ze względu, iż kubity moga znajdowac się w superpozycji stanów, komputer kwantowy może przeprowadzic obliczenia jednocześnie na wszystkich stanach. Co dokładnie to oznacza, poznamy w dalszej czesci wykładu. Rozważmy sytuację w której chcemy poznac działanie funkcji \\(f(x)\\) dla pewnego argumentu \\(x\\) (dla pewnej liczby). Aby znaleźc wynik dla dwóch liczb (np. \\(x=0\\) i \\(x=1\\)) klasyczny komputer musi wykonac dwie operacje. Komputer kwantowy może uzuskac ten wynik przeprowadzajac obliczenia jednocześnie dla obu warości. Do wykonania takiej operacji wystarczy jeden kubit. Następnie jeżeli będziemy chcieli obliczyc nasza funkcję dla kolejnych liczb \\(x=2\\) (która binarnie reprezentowana jest jako \\(10\\)) oraz liczby \\(x=3\\) (binarnie \\(11\\)) musimy dodac kolejny (jeden!) kubit. Dwa kubity moga posłużyc do realizacji czterech równoległych operacji. Jeśli rozważymy 3 kubity znowu mozemy podwoic ilośc operacji (3 kubity maja 8 stanów bazowych). Dodanie kubitu do komputera kwantowego pozwala podwoic liczbę obliczeń. W przypadku klasycznego komputera aby uzyskac taki efekt, potrzeba podwoic rownież liczbę bitów. n-kubitów moze realizowac \\(2^n\\) równoległych obliczeń.\nDruga istotna koncepcja jest pamięc. Klasyczne komputery (np. 64-bitowy laptop) każda liczbę moga zareprezentowac w 64-biotwej reprezentacji (rozszerzenie reprezentacji 8 bitowej). Jeśli chcemy otrzymac 4 liczby w takiej reprezentacji potrzebujemy \\(4\\times 64=256\\) bitów pamięci na twardym dysku. Dla \\(M\\) liczb potrzebujemy zatem \\(M \\times 64\\) bitów pamięci. W przypadku komputera kwantowego operujacego na n-kubitach możemy przechowac \\(2^n\\) różnych współczynników traktujac taki stan jako pamięc. W odróżnieniu od klasycznej pamięci, gdzie ilośc bitów pamięci jest liniowa w stosunku do ilości liczb, pamięc realizowana na kubitach jest funkcja logarytmiczna od ilości liczb.\nDzisiejsze Klasyczne komputery to zaawansowane maszyny zwieraja dziesiatki terabajtów pamięci i moga symulowac niewielki układy kwantowe. Obecnie najwieksze komputery potrafia symulowac ok 46 kubitów. Dla porównania obecnie IBM pozwala użytkowac komputer kwantowy oparty o 127 kubitów (a nawet 1000).\n\n\nKwantowa Korekcja Błędów (Quantum Error Correction)\nDekoherencja, czyli oddziaływanie z otoczeniem, niszczy stan komputera kwantowego i wprowadza błędy obliczeniowe. Istnieje potrzeba zabezpieczenia przed tym zjawiskiem. Obliczenia kwantowe wymagają tzw. korekcji błędów, która pomaga w utrzymaniu integralności obliczeń na komputerach kwantowych. Aktualnie mówimy o erze Noisy Intermediate-Scale Quantum (NISQ), co oznacza, że komputery kwantowe wciąż potrzebują rozwoju w zakresie korekcji błędów i stabilności.\n\n\n\nRealizacja fizyczna komputerów kwantowych\nprocesory kwantowe\n\n\n\nProces obliczeń kwantowych\nWykonanie obliczeń związane jest z pojęciem fizycznego doświadczenia. Będzie się ono składać z trzech części:\n\nprzygotowanie (przygotuj stan kwantowy kubitów),\newolucja (przeprowadź transformację za pomocą bramek kwantowych),\npomiar i interpretacja wyników.\n\n\nPodobnie w informatyce i w analizach danych wykonujemy obliczenia klasyczne. przygotowujemy dane (stan początkowy); następnie wykonujemy program (ewolucja) i odczytujemy wyniki (pomiar).\n\nNie obserwujemy tych etapów podczas codziennej interakcji z komputerem, więc nie zauważamy w sposób świadomy powyższego schematu działania. Piotr Gawron, Oscar Słowik - Rewolucja Stanu, Fantastyczne wprowadzenie do informatyki kwantowej.\n\nKażdy komputer kwantowy (koprocesor) musi komunikować się z podukładem klasycznym."
  },
  {
    "objectID": "lectures/wyklad1.html#quantum-machine-learning",
    "href": "lectures/wyklad1.html#quantum-machine-learning",
    "title": "Komputery klasyczne i kwantowe",
    "section": "Quantum Machine Learning",
    "text": "Quantum Machine Learning\n\nDane w QML\n\n\nCC - Classical data using classical computers, algorytmy inspirowane obliczeniami kwantowymi\nQC - Quantum data using classical (ML) computers. link1, link2, link3\nCQ - Classical data on qunatum computers. Na tym chcemy się skupić.\nQQ - Quantum data on quantum computers. Who knows?\n\n\n\nRealizacje problemów biznesowych na komputerach kwantowych\n\nSystemy obrony - kryptografia\nRigetti - przewidywanie pogody\nNASA (QuAIL) - Kontrola lotów kosmicznych\nAccenture - Finanse, logistyka, komunikacja i systemy bezpieczeństwa\nBASF - Obliczenia molekularne w chemii kwantowej.\nFord link\nVolkswagen link\nBMW link\nBoeing/Airbus\nGoldman Sach / JPMorgan\nDWave DWave and VW\nIBM Case study\nIBM 127 qubitów\nQuantum Natural Language Processing link\n\n\n\nDostęp do obliczeń kwantowych w chmurze\n\nIBM Quantum z wykorzystaniem biblioteki qiskit.\nPennylane z wykorzystaniem biblioteki pennylane.\nCirq Google z wykorzystaniem biblioteki cirq."
  },
  {
    "objectID": "lectures/wyklad2.html",
    "href": "lectures/wyklad2.html",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "",
    "text": "\\[\n\\newcommand{\\bra}[1]{\\left \\langle #1 \\right \\rvert}\n\\newcommand{\\ket}[1]{\\left \\rvert #1 \\right \\rangle}\n\\newcommand{\\braket}[2]{\\left \\langle #1 \\middle \\rvert #2 \\right \\rangle}\n\\]\nObliczenia (przetwarzanie) wykonywane przez komputer możemy zdefiniować jako transformacje jednego stanu pamięci na inny. Z matematycznego punktu widzenia oznacza to, że obliczenia to funkcje, które przekształcają informacje.\nW przypadku klasycznych komputerów podstawową jednostką pamięci jest bit (ang. binary digit). Funkcje, które operują na bitach nazywamy bramkami logicznymi (ang. logic gates)."
  },
  {
    "objectID": "lectures/wyklad2.html#bramki-logiczne",
    "href": "lectures/wyklad2.html#bramki-logiczne",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "Bramki logiczne",
    "text": "Bramki logiczne\nBramki logiczne to funkcje Boolowskie, które możemy składać w bardziej złożone układy (ang. circuits). Stworzone przez George’a Boole’a w 1854 roku, algebra boola jest matematyczną strukturą, która opisuje zachowanie się obiektów, które mogą przyjmować tylko jedną z dwóch wartości: prawda lub fałsz. Zdolne są one do wykonywania np. dodawania, mnożenia czy też innych bardziej skomplikowanych operacji.\nW latach trzydziestych XX wieku Claude Shannon zastosował algebrę boola do analizy i projektowania układów elektrycznych. Co oznacza, że zareprezentował on funkcje boolowskie za pomocą przełączników elektrycznych. Dlatego też komponenty elektroniczne odpowiadające funkcjom boolowskim nazywamy bramkami logicznymi.\n\nCiekawostka. Richard Feynman wykładał teorię obliczeń na Kalifornijskim Instytucie Technologii. Wykład ten prezentowany jest obecnie jako Feynmana wykłady o obliczeniach (ang. Feynman Lectures on Computation).\n\n\nZ pozoru obliczenia przedstawione w ten sposób wyglądają jako abstrakcjny matematyczny koncept. Jednak jego realizacja zawsze wymaga jakiegoś układu fizycznego realizującego wykonywanie funkcji. Nie ma znaczenia jak ten układ zostanie zrealizowany: kule bilardowe, przełączniki elektroniczne, tranzystory, czy cokolwiek innego.\n\nLogika obliczeń jest niezależna od realizacji bramek logicznych.\n\nZ punktu widzenia realizacji zawsze chodzi nam o kontrolowany sposób zmiany stanu układu.\nNa wykładzie postaramy się wskazać jak i kiedy logika klasycznych obliczeń może być uogólniona przez logikę obliczeń kwantowych. Jasne jest, że przypadek klasyczny powinien być szczególnym przypadkiem kwantowego.\nobwody klasyczne\nZobaczmy jakie bramki możemy określić dla jednego bitu.\n\nBramki logiczne dla jednego bitu\nIle bramek mamy gdy input = 1 bit, output = 1 bit? Ile funkcji możemy zdefiniować dla odwzorowania jednego bitu w jeden bit?\nWszystkie cztery operatory działające na jednym bicie możemy określić jako:\n\nIdentyczność (ang. identity) - \\(I(0)=0\\), \\(I(1)=1\\)\nNegacja (ang. negation, NOT, filps) - \\(NOT(0)=1\\), \\(NOT(1)=0\\)\nStałe zero \\(ZERO(0)=0\\), \\(ZERO(1)=0\\)\nStałe jeden \\(ONE(0)=1\\), \\(ONE(1)=1\\)\n\nPo zastosowaniu operatora \\(I\\) oraz \\(NOT\\), z otrzymanego wyniku możemy wyznaczyc wartości początkowe. Jednak po zastosowaniu dwóch pozostałych operacji \\(ZERO\\) i \\(ONE\\) nie jesteśmy w stanie określic jaki był stan początkowy, który wygenerował określony wynik.\nTe dwie własności pozwalają nam sklasyfikowac operatory jako:\n\nOdwracalne - możemy odtworzyc wartośc początkową z wartości końcowej\nNieodwracalne - NIE możemy odtworzyc wartości początkowej z wartości końcowej.\n\nJak pokażemy później, wszystkie operatory reprezentujące kwantowe bramki będą odwracalne.\n\n\nInne bramki i operacje logiczne\n\nZróbmy krótkie przedstawienie niektórych, klasycznych bramek logicznych.\nBramka logiczna jest implementacją funkcji boolowskiej. Operacją logiczną przeprowadzaną na jednym lub kilku binarnych wejściach produkującą jedną binarną wartość wyjściową. \\[f: \\{0,1\\}^{n} \\to \\{0,1\\} \\]\nKażdy element algebry boola (Boolean Statements) musi być określony jako prawda albo fałsz.\nBramki logiczne możemy wyrazić za pomocą tablicy prawdy (ang. truth table). Tablica ta posiada jedną kolumnę dla każdej zmiennej wejściowej oraz jedną kolumnę dla zmiennej wyjściowej. Kolumna wyjściowa przedstawia wszystkie możliwe wyniki przedstawianej logicznej operacji reprezentowanej przez tablicę. Każdy wiersz tablicy prawdy reprezentuje jedną możliwą kombinację (konfiguracje) danych wejściowych oraz wyniku.\nPodstawowe bramki, które znasz to:\n\nAND - koniunkcja\nOR - alternatywa\nNOT - negacja\nNAND - not and\nXOR - alternatywa wykluczająca (Exclusive OR) - dodawanie modulo 2\n\n\nZadanie: zapisz tablicę prawdy dla każdej bramki.\n\n\nNOT gate\n\n\n\nA\nnot A\n\n\n\n\n0\n\n\n\n1\n\n\n\n\n\n\nAND gate\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\n\n\nOR gate\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\n\n\nNAND\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\n\n\nXOR\n\n\n\nA\nB\nC\n\n\n\n\n0\n0\n\n\n\n1\n0\n\n\n\n0\n1\n\n\n\n1\n1\n\n\n\n\nPowyższe bramki pozwalają łączyć poszczególne elementy algebry boola ze sobą.\n\nZadanie: Porównaj AND oraz OR z potocznym znaczeniem tych słów.\n\n\nZadanie: Dlaczego Algebra boola nazywana jest algebrą zbiorów?\n\n\nZadanie: Czy składanie podzbiorów zbioru również generuje algebrę boola ?\n\n\nZadanie: ile bramek logicznych możemy stworzyć dla jednego bitu, dwóch bitów, trzech bitów?\n\n\n\n\nUniweralne bramki logiczne - NAND\nTak jak widzieliśmy dla 1-bitu informacji mieliśmy 4 bramki logiczne. Dla 2-bitów mieliśmy 16 bramek logicznych. Dla 3-bitów mamy już 256 możliwości.\nW przypadku 2-bitów nie wypisaliśmy wszystkich bramek, dlaczego?\nCzy musimy realizować wszystkie?\n\nNa szczęście odpowiedź jest negatywna.\n\nIstnieją tzw. zbiory bramek uniwersalnych dzięki którym możemy zrealizować dowolną funkcję boolowską.\n\nNOT, AND, OR\nNAND, AND\nNAND\nNOT, OR\nNOR"
  },
  {
    "objectID": "lectures/wyklad2.html#kody-python",
    "href": "lectures/wyklad2.html#kody-python",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "Kody python",
    "text": "Kody python\n\nZadanie 1: Napisz kod symuljący wyrzucenie symetrycznej monety \\(100\\), \\(1000\\), \\(10000\\) i \\(100000\\) razy\n\nfrom random import randrange\n# randrange(n) zwraca losową wartośc z przedziału (0,...,n-1)\n# Twoje rozwiązanie \n\nZadanie 2: Napisz kod symulujący wyrzucenie niesymetrycznej monety gdzie prawdopodobieństwo wyrzucenia orła będzie wynosiło \\(60\\%\\).\n\nfrom random import randrange\n# randrange(n) zwraca losową wartośc z przedziału (0,...,n-1)\n# Twoje rozwiązanie"
  },
  {
    "objectID": "lectures/wyklad2.html#szyfrowanie-z-wykorzystaniem-bramki-xor",
    "href": "lectures/wyklad2.html#szyfrowanie-z-wykorzystaniem-bramki-xor",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "Szyfrowanie z wykorzystaniem bramki XOR",
    "text": "Szyfrowanie z wykorzystaniem bramki XOR\nWeźmy dwie sekwencje bitów:\nsekwencja A - przedstawiająca naszą zakodowaną wiadomośc: \\[1 0 1 1 0 1 1 1 0 0 0\\]\nlosowa sekwencja B: \\[0 1 1 0 1 1 0 1 1 0 1\\]\ni obliczmy XOR między dwoma sekwencjami (dla poszczególnych kolumn) \\(A\\) XOR \\(B\\).\nZgodnie z tablicą prawdy dla XOR otrzymujemy: \\[1 1 0 1 1 0 1 0 1 0 1\\]\nNa otrzymanym wyniku jeszcze raz zastosuj bramkę XOR.\nCo możesz zauważyć?\n\nOblicz A XOR B XOR B.\n\nZamień wiadomość, którą chcesz zaszyfrować na binarną postać (czyli jako sekwencję zer i jedynek).\nWeź losową sekwencję bitów (klucz szyfrujący), którą zna tylko nadawca i odbiorca.\n\\(1001011010...\\) - wiadomość\n\\(0110101010...\\) - klucz szyfrujący, czyli losowa sekwencja bitów\nZaszyfruj wiadomość wykonując operację XOR na każdym bicie wiadomości i klucza szyfrującego. Tak otrzymaną wiadomość (zaszyfrowaną) wyślij do odbiorcy.\n\ndecyrpting message\nOdbiorca otrzymuje zaszyfrowaną wiadomość (posiada klucz szyfrujący).\nMessage XOR SecretSequence = EncryptedMessage\nMessage XOR SecretSequence XOR SecretSequence = Message\nNie powinniśmy używać SecretSequence więcej niż raz. Jeśli użyjemy jej więcej niż raz, to łatwo jest złamać szyfrowanie.\n\nDlaczego nie powinno się używać szyfru więcej niż jeden raz? Podpowiedź: Zakodowana wiadomość przestaje być losowa."
  },
  {
    "objectID": "lectures/wyklad2.html#kody---rozwiązania-zadań",
    "href": "lectures/wyklad2.html#kody---rozwiązania-zadań",
    "title": "Klasyczne bramki logiczne - Algebra Boola",
    "section": "kody - rozwiązania zadań",
    "text": "kody - rozwiązania zadań\n\nfrom random import randrange\n# randrange(n) zwraca losową wartośc z przedziału (0,...,n-1)\nfor experiment in [100,1000,10000,100000]:\n    heads = tails = 0\n    for i in range(experiment):\n        if randrange(2) == 0: heads = heads + 1\n        else: tails = tails + 1\n    print(\"experiment:\",experiment)\n    print(\"heads =\",heads,\"  tails = \",tails)\n    print(\"the ratio of #heads/#tails is\",(round(heads/tails,4)))\n    print() # empty line\n\nexperiment: 100\nheads = 54   tails =  46\nthe ratio of #heads/#tails is 1.1739\n\nexperiment: 1000\nheads = 518   tails =  482\nthe ratio of #heads/#tails is 1.0747\n\nexperiment: 10000\nheads = 5033   tails =  4967\nthe ratio of #heads/#tails is 1.0133\n\nexperiment: 100000\nheads = 49838   tails =  50162\nthe ratio of #heads/#tails is 0.9935\n\n\n\n\nfrom random import randrange\n\n# let's pick a random number between {0,1,...,99}\n# it is expected to be less than 60 with probability 0.6\n#     and greater than or equal to 60 with probability 0.4\n# ten sam przypadek możesz zrealizować dla losowania wartosci rzeczywistej\n# pomiędzy 0 i 1.\n\nfor experiment in [100,1000,10000,100000]:\n    heads = tails = 0\n    for i in range(experiment):\n        if randrange(100) &lt;60: heads = heads + 1 # with probability 0.6\n        else: tails = tails + 1 # with probability 0.4\n    print(\"experiment:\",experiment)\n    print(\"heads =\",heads,\"  tails = \",tails)\n    print(\"the ratio of #heads/#tails is\",(round(heads/tails,4)))\n    print() # empty line\n\nexperiment: 100\nheads = 64   tails =  36\nthe ratio of #heads/#tails is 1.7778\n\nexperiment: 1000\nheads = 601   tails =  399\nthe ratio of #heads/#tails is 1.5063\n\nexperiment: 10000\nheads = 6073   tails =  3927\nthe ratio of #heads/#tails is 1.5465\n\nexperiment: 100000\nheads = 60130   tails =  39870\nthe ratio of #heads/#tails is 1.5082"
  },
  {
    "objectID": "cwiczenia/cw3.html",
    "href": "cwiczenia/cw3.html",
    "title": "Bramki wielokubitowe",
    "section": "",
    "text": "from qiskit import (QuantumCircuit, QuantumRegister, ClassicalRegister, \n                    execute, Aer, __qiskit_version__)\nfrom qiskit.visualization import plot_bloch_multivector\nimport matplotlib as mpl\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')\ndef obwod(strategia):\n    qc = QuantumCircuit(QuantumRegister(1, name='qGra'))\n    for bramka in strategia:\n        if bramka == 'I':\n            qc.id(0)\n        elif bramka == 'H':\n            qc.h(0)\n        elif bramka == 'X':\n            qc.x(0)\n    return qc\n\n%matplotlib inline\ndef animacja(strategia):\n    qc = QuantumCircuit(QuantumRegister(1, name=\"q0\"))\n    symulator = Aer.get_backend('statevector_simulator')\n    wynik = execute(qc, backend=symulator).result()\n    stan = wynik.get_statevector()\n    display(stan)\n    print(\"stan poczatkowy:\")\n    display(plot_bloch_multivector(stan))\n    plt.show()\n    for it, bramka in enumerate(strategia):\n        if bramka == 'I':\n            qc.id(0)\n        elif bramka == 'H':\n            qc.h(0)\n        elif bramka == 'X':\n            qc.x(0)\n        wynik = execute(qc, backend=symulator).result()\n        stan = wynik.get_statevector()\n        print(\"stan po bramce\", bramka)\n        display(plot_bloch_multivector(stan))\n        plt.show()\nstrategia = 'XXX'\ndisplay(obwod(strategia).draw('mpl'))\nanimacja(strategia)\n\n\n\n\nStatevector([1.+0.j, 0.+0.j],\n            dims=(2,))\nstan poczatkowy:\nstan po bramce X\nstan po bramce X\nstan po bramce X\ndef sedzia(obwod):\n    qr = QuantumRegister(1)\n    cr = ClassicalRegister(1)\n    ob = QuantumCircuit(qr, cr)\n    ob.append(obwod, qr)\n    ob.measure(0, 0)\n    return  execute(ob, backend=Aer.get_backend('qasm_simulator'), shots=1000).result()\nstrategia = 'XXX'\nstats = sedzia(obwod(strategia)).get_counts()\nprint(stats)\n\n{'1': 1000}\nstrategia = 'HXH'\nstats = sedzia(obwod(strategia)).get_counts()\nprint(stats)\n\n{'0': 1000}\ndef klasycze_strategie():\n    wyniki = []\n    for ruch_1 in ['I','X']:\n        for ruch_2 in ['I','X']:\n            for ruch_3 in ['I','X']:\n                strategia = ruch_1 + ruch_2 + ruch_3\n                print(\"strategia\",strategia)\n                ob = obwod(strategia)\n                display(ob.draw('mpl'))\n                plt.show()\n                stats = sedzia(ob).get_counts()\n                print(\"statystyka\", stats)\n                wyniki.append((strategia, stats))\nklasycze_strategie()\n\nstrategia III\nstatystyka {'0': 1000}\nstrategia IIX\nstatystyka {'1': 1000}\nstrategia IXI\nstatystyka {'1': 1000}\nstrategia IXX\nstatystyka {'0': 1000}\nstrategia XII\nstatystyka {'1': 1000}\nstrategia XIX\nstatystyka {'0': 1000}\nstrategia XXI\nstatystyka {'0': 1000}\nstrategia XXX\nstatystyka {'1': 1000}\ndef kwantowe_strategie():\n    wyniki = []\n    for ruch_1 in ['H']:\n        for ruch_2 in ['I','X']:\n            for ruch_3 in ['H']:\n                strategia = ruch_1 + ruch_2 + ruch_3\n                print(\"strategia\",strategia)\n                ob = obwod(strategia)\n                display(ob.draw('mpl'))\n                plt.show()\n                stats = sedzia(ob).get_counts()\n                print(\"statystyka\", stats)\n                wyniki.append((strategia, stats))\nkwantowe_strategie()\n\nstrategia HIH\nstatystyka {'0': 1000}\nstrategia HXH\nstatystyka {'0': 1000}"
  },
  {
    "objectID": "cwiczenia/cw3.html#losowy-bajt",
    "href": "cwiczenia/cw3.html#losowy-bajt",
    "title": "Bramki wielokubitowe",
    "section": "Losowy bajt",
    "text": "Losowy bajt\n\n# generator liczb losowych\nfrom random import randrange\n''.join([str(randrange(2)) for i in range(8)])\n\n'00011001'\n\n\n\n# mozna takze zrealizowac jako rzut monetą \n\nimport random\nfor n in range(5):\n    if random.random()&lt;0.5:       #if the random number is less than 0.5 print heads\n        print('HEADS')\n    else:\n        print('TAILS')\n\nHEADS\nTAILS\nTAILS\nHEADS\nTAILS\n\n\n\n# LOSOWY BAJT \nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer\nq = QuantumRegister(8)\nc = ClassicalRegister(8)\n\nqc = QuantumCircuit(q,c)\n# tutaj kod losowania \nfor i in range(8):\n    if randrange(2) == 0:\n        qc.x(q[i])\n        \nqc.barrier()\nqc.measure(q,c)\nqc.draw('mpl')\n\n\n\n\n\njob = execute(qc, Aer.get_backend('qasm_simulator'), shots=10)\ncounts = job.result().get_counts()\n\n\ncounts\n\n{'00100100': 10}\n\n\n\nprint(list(counts)[0], \"wynosi: \", int(list(counts)[0],2))\n\n00100100 wynosi:  36\n\n\n\n# losowy kwantowo bajt \n# LOSOWY BAJT \nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer\nq = QuantumRegister(8)\nc = ClassicalRegister(8)\n\nqc = QuantumCircuit(q,c)\n# tutaj kod losowania \nqc.h(q)        \nqc.barrier()\nqc.measure(q,c)\ndisplay(qc.draw('mpl'))\njob = execute(qc, Aer.get_backend('qasm_simulator'), shots=10)\ncounts = job.result().get_counts()\ncounts\n\n\n\n\n{'01000110': 1,\n '00001001': 1,\n '00100100': 1,\n '11000000': 1,\n '01000011': 1,\n '11010001': 1,\n '11100110': 1,\n '11100100': 1,\n '10101011': 1,\n '11001100': 1}\n\n\n\nfor el in counts:\n    print(int(el,2))\n\n70\n9\n36\n192\n67\n209\n230\n228\n171\n204\n\n\n\n# losowanie z zakresu liczb 0-15 \nn = 4\nq = QuantumRegister(n)\nc = ClassicalRegister(n)\ncircuit = QuantumCircuit(q, c)\n\nfor j in range(n):\n    circuit.h(q[j])\n    \ncircuit.measure(q,c)\n\njob = execute(circuit,  Aer.get_backend('qasm_simulator'), shots=1000)\n\n# get the histogram of bit string results, convert it to one of integers and plot it\nbit_counts = job.result().get_counts()\nint_counts = {}\nfor bitstring in bit_counts:\n    int_counts[ int(bitstring,2) ] = bit_counts[bitstring]\n\nfrom qiskit.tools.visualization import plot_histogram    \nplot_histogram(int_counts)"
  },
  {
    "objectID": "cwiczenia/cw3.html#swap-gate",
    "href": "cwiczenia/cw3.html#swap-gate",
    "title": "Bramki wielokubitowe",
    "section": "SWAP GATE",
    "text": "SWAP GATE\n\\[\n\\text{SWAP}\\ket{01} = \\ket{10}\n\\]\n\nqc = QuantumCircuit(2)\nqc.x(0)\nqc.swap(0,1)\nqc.measure_all()\nqc.draw('mpl')\n\n\n\n\n\ncounts = execute(qc, Aer.get_backend('qasm_simulator'), shots=1).result()\ncounts.get_counts()"
  },
  {
    "objectID": "cwiczenia/cw3.html#stany-splątane",
    "href": "cwiczenia/cw3.html#stany-splątane",
    "title": "Bramki wielokubitowe",
    "section": "Stany splątane",
    "text": "Stany splątane\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.cx(0,1)\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\n\n\ndisplay(qc.draw('mpl'))\nstate.draw('latex')\n\n\n\n\n\\[\\frac{\\sqrt{2}}{2} |00\\rangle+\\frac{\\sqrt{2}}{2} |11\\rangle\\]\n\n\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.cx(0,1)\nqc.x(1)\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\ndisplay(qc.draw('mpl'))\nstate.draw('latex')\n\n\n\n\n\\[\\frac{\\sqrt{2}}{2} |01\\rangle+\\frac{\\sqrt{2}}{2} |10\\rangle\\]\n\n\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.cx(0,1)\nqc.z(1)\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\ndisplay(qc.draw('mpl'))\nstate.draw('latex')\n\n\n\n\n\\[\\frac{\\sqrt{2}}{2} |00\\rangle- \\frac{\\sqrt{2}}{2} |11\\rangle\\]\n\n\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.cx(0,1)\nqc.x(1)\nqc.z(1)\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\ndisplay(qc.draw('mpl'))\nstate.draw('latex')\n\n\n\n\n\\[\\frac{\\sqrt{2}}{2} |01\\rangle- \\frac{\\sqrt{2}}{2} |10\\rangle\\]"
  },
  {
    "objectID": "cwiczenia/cw3.html#half-adder-cirquit",
    "href": "cwiczenia/cw3.html#half-adder-cirquit",
    "title": "Bramki wielokubitowe",
    "section": "Half adder cirquit",
    "text": "Half adder cirquit\n\nNapisz operator 1+1 na układzie 4 kubitów\n\\[\n0+0 = 00\n\\] \\[\n0+1 = 01\n\\] \\[\n1+0 = 01\n\\] \\[\n1+1 = 10\n\\]\nzauwaz, ze mamy dwa typy rozwiązań:\n\ndwa bity wejsciowe są takie same (00, 11) i dają na prawym bicie odpowiedzi 0.\ndwa bity wejsciowe są rózne (10,01) i dają na prawym bicie odpowiedzi 1.\n\nAby napisać prawidłowe rozwiązanie musimy stworzyć bramki, które będą rozpoznawać czy dwa kubity są takie same czy tez rózne. Dla przypomnienia - klasycznie rolę taką pełni bramka XOR.\n\n\n\nInput 1\nInput 2\nXOR\n\n\n\n\n0\n0\n0\n\n\n0\n1\n1\n\n\n1\n1\n1\n\n\n1\n0\n0\n\n\n\nPodobnie działa bramka CNOT\n\nqc  = QuantumCircuit(2)\nqc.cx(0,1)\nqc.draw(output='mpl')\n\n\n\n\n\nqc = QuantumCircuit(4,2)\n# zakodowanie danych wejściowych do kubitu 1 i 2 \nqc.x(0) \nqc.x(1) # bo chcemy policzyc 1+1 \n# uzyjemy CNOT - bramka XOR dla porownania kubitow 1 i 2\nqc.cx(0,2)\nqc.cx(1,2)\nqc.measure(2,0) # wydobycie wyniku XOR\nqc.measure(3,1) # wydobycie wyniku AND\nqc.draw(output='mpl')\n\n\n\n\nZastosowanie dwóch CNOT do inputów rozwiązuje nam problem prawego bitu odpowiedzi.\nCo z pierszym bitem odpowiedzi otrzymywanym po pomiarzze q3 ?\n\njego wartość dla pierwszych trzech równań zawsze wynosi 0.\n\nJednak dla równania 1+1 powinniśmy otrzymać 1.\nDo rozwiązania tego problemu mozna wykorzystać bramkę operującą na 3 kubitach. Bramka ta to bramka Toffoli.\n\nqc = QuantumCircuit(4,2)\n# zakodowanie danych wejściowych do kubitu 1 i 2 \nqc.x(0) \nqc.x(1) # bo chcemy policzyc 1+1 \n# uzyjemy CNOT\nqc.cx(0,2)\nqc.cx(1,2)\nqc.ccx(0,1,3) # AND\nqc.measure(2,0) # wydobycie wyniku XOR\nqc.measure(3,1) # wydobycie wyniku AND\nqc.draw(output='mpl')\n\n\n\n\n\nfrom qiskit.visualization import plot_histogram\ncounts = execute(qc,Aer.get_backend('qasm_simulator'),shots=1).result().get_counts()\nplot_histogram(counts)\n\n\n\n\nDla przypomnienia:\n\nprint(\"wynik 1+1 =\",int('10',2))\n\nwynik 1+1 = 2\n\n\nsprawdźmy wszystkie mozliwe wyniki\n\nfor input in ['00','01','10','11']:\n    \n    mycircuit1 = QuantumCircuit(4,2)\n    \n    #Initialization - Note qiskit order\n    if input[0] == '1':\n        mycircuit1.x(1)\n    if input[1] == '1':\n        mycircuit1.x(0)\n\n    mycircuit1.cx(0,2)\n    mycircuit1.cx(1,2)\n    mycircuit1.ccx(0,1,3)\n\n    mycircuit1.measure(2,0)\n    mycircuit1.measure(3,1)\n\n    job = execute(mycircuit1,Aer.get_backend('qasm_simulator'),shots=1)\n    counts = job.result().get_counts(mycircuit1)\n    print(\"Input:\", input, \"Output:\", counts)\n\nInput: 00 Output: {'00': 1}\nInput: 01 Output: {'01': 1}\nInput: 10 Output: {'01': 1}\nInput: 11 Output: {'10': 1}\n\n\n\nZadanie - czy potrafisz utworzyć 3 kubitową wersję bramki OR"
  },
  {
    "objectID": "cwiczenia/cw2.html",
    "href": "cwiczenia/cw2.html",
    "title": "Bramki jednokubitowe",
    "section": "",
    "text": "Bramka X\nBramka X-gate reprezentowana jest przez macierz Pauli-X :\n\\[\nX = \\begin{pmatrix}\n0 & 1 \\\\\n1 & 0 \\\\\n\\end{pmatrix}\n\\]\nBramka X obraca kubit w kierunku osi na sferze Bloch’a o \\(\\pi\\) radianów. Zmienia \\(|0\\rangle\\) na \\(|1\\rangle\\) oraz \\(|1\\rangle\\) na \\(|0\\rangle\\). Jest często nazywana kwantowym odpowiednikiem bramki NOT lub określana jako bit-flip.\n\nfrom qiskit import QuantumCircuit, Aer, execute\n\nx_gate = QuantumCircuit(1)\nx_gate.x(0)\nx_gate.draw(output='mpl')\n\n\n\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nbackend = Aer.get_backend('statevector_simulator')\nstate = execute(x_gate, backend).result().get_statevector()\nstate.draw('latex')\nplot_bloch_multivector(state)\n\n\n\n\n\nx_gate2 = QuantumCircuit(1)\nx_gate2.x(0)\nx_gate2.x(0)\nx_gate2.draw('mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nstate = execute(x_gate2, backend).result().get_statevector()\nstate.draw('latex')\nplot_bloch_multivector(state)\n\n\n\n\n\n\nbramka SX\nBramka SX jest pierwiastkiem kwadratowym bramki X. Dwukrotne zastosowanie powinno reazlizowac bramkę X.\n\\[\nSX = \\frac{1}{2}\\begin{pmatrix}\n1+i & 1-i \\\\\n1-i & 1+i \\\\\n\\end{pmatrix}\n\\]\n\nsx_gate = QuantumCircuit(1)\nsx_gate.sx(0)  \nsx_gate.draw(output='mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(sx_gate, backend).result().get_statevector()\nplot_bloch_multivector(result)\n\n\n\n\n\nsx_gate2 = QuantumCircuit(1)\nsx_gate2.sx(0)\nsx_gate2.sx(0)\nsx_gate2.draw(output='mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(sx_gate2, backend).result().get_statevector()\nplot_bloch_multivector(result)\n\n\n\n\n\n\nZ gate\n\\[\nZ = \\begin{pmatrix}\n1 & 0 \\\\\n0 & -1 \\\\\n\\end{pmatrix}\n\\]\n\nz_gate = QuantumCircuit(1)\nz_gate.z(0)  \nz_gate.draw(output='mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(z_gate, backend).result().get_statevector()\nplot_bloch_multivector(result)\n\n\n\n\n\n\nRZ gate\n\\[\nRZ = \\begin{pmatrix}\n1 & 0 \\\\\n0 & e ^{i \\phi } \\\\\n\\end{pmatrix}\n\\]\n\nimport numpy as np\npi = np.pi\nrz_gate = QuantumCircuit(1)\nrz_gate.rz(pi/2, 0)\nrz_gate.draw(output='mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(rz_gate, backend).result().get_statevector()\nplot_bloch_multivector(result)\n\n\n\n\n\nrz_gate2 = QuantumCircuit(1)\nrz_gate2.sx(0)\nrz_gate2.rz(pi/2, 0)\nrz_gate2.draw(output='mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(rz_gate2, backend).result().get_statevector()\nplot_bloch_multivector(result)\n\n\n\n\n\n\nHadamard gate\nBramka Hadamarda przetwarza stan \\(|0\\rangle\\) na kombinacje liniowa (superpozycje) \\(\\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}}\\), co oznacza, że pomiar zwróci z takim samym prawdopodobieństwem stanu 1 lub 0. Stan ten często oznaczany jest jako: \\(|+\\rangle\\).\n\\[\nH = \\frac{1}{\\sqrt{2}}\\begin{pmatrix}\n1 & 1 \\\\\n1 & -1 \\\\\n\\end{pmatrix}\n\\]\n\nh_gate = QuantumCircuit(1)\nh_gate.h(0)\nh_gate.draw(output='mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(h_gate, backend).result().get_statevector()\nplot_bloch_multivector(result)\n\n\n\n\n\nh_gate2 = QuantumCircuit(1)\nh_gate2.h(0)\nh_gate2.h(0)\nh_gate2.draw('mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nstate = execute(h_gate2, backend).result().get_statevector()\ndisplay(state.draw('latex'))\nplot_bloch_multivector(state)\n\n\\[ |0\\rangle\\]\n\n\n\n\n\n\n\nBramka parametryzowana Ry\n\\[\nR(\\alpha) = \\begin{pmatrix}\n\\cos{\\alpha} & -\\sin{\\alpha}\\\\\n\\sin{\\alpha} & \\cos{\\alpha} \\\\\n\\end{pmatrix}\n\\]\n\nry_gate = QuantumCircuit(1)\npi = np.pi\nry_gate.ry(pi/2,0)\nry_gate.draw(output='mpl')\n\n\n\n\n\nbackend = Aer.get_backend('statevector_simulator')\nresult = execute(ry_gate, backend).result().get_statevector()\nplot_bloch_multivector(result)\n\n\n\n\n\n\nCX gate (CNOT gate)\nThe controlled NOT (or CNOT or CX) gate acts on two qubits. It performs the NOT operation (equivalent to applying an X gate) on the second qubit only when the first qubit is \\(\\ket{1}\\) and otherwise leaves it unchanged.\nNote: Qiskit numbers the bits in a string from right to left.\n\\[\nCX = \\begin{pmatrix}\n1 & 0 & 0 & 0  \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0 \\\\\n\\end{pmatrix}\n\\]\n\ncx_gate = QuantumCircuit(2)\ncx_gate.cx(0,1)\ncx_gate.draw(output='mpl')\n\n\n\n\n\nZadanie 1 - Sprawdź działanie bramki - CZ na dwukubitowym układzie. Następnie zbuduj drugi obwód złożony z bramek: H(1) (na drugim kubicie) CX(0,1) i H(1) - co możesz zaobserwować?\nZadanie 2 - zbuduj obwod kwantowy złożony z 10 kubitów, zastosuj bramkę H(0) do kubitu 0 i 9 bramek CNOT gdzie kubitem kontrolnym jest kubit 0 a targety to kubity od 1 do 9. Mozesz uzyć do pętli albo listy.\nZadanie 3 - zbuduj obwod kwantowy złożony z 10 kubitów. Zastosuj bramkę H do całego rejestru kwantowego.Następnie dodaj bramkę CNOT gdzie kubitami kontrolnymi sa kubity 1-9 a target to kubit 0. Następnie dodaj bramkę H do każdego kubitu.\n\nPrzydatne definicje dla obwodów\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n\nq = QuantumRegister(10)\nc = ClassicalRegister(10)\nci = QuantumCircuit(q,c)\nci.h(q)\nci.draw('mpl')\n\n\n\n\n\n# CCCH gate\nfrom qiskit.circuit.library.standard_gates import HGate\n\nCCCH = HGate().control(3)\n\nci.append(CCCH, [0,1,3,2])\nci.draw('mpl')"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod: 232530-D\nSemestr zimowy 2023/2024,\nSGH Szkoła Główna Handlowa w Warszawie\nPodstawowe informacje znajdziesz w sylabusie.\nCiekawe książki i strony internetowe zamieszczone zostały w zakładce książki. Jeśli chciał(a)byś coś dodać prześlij informację przez MS teams."
  },
  {
    "objectID": "index.html#var-main.nazwa",
    "href": "index.html#var-main.nazwa",
    "title": "Informacje ogólne",
    "section": "",
    "text": "Kod: 232530-D\nSemestr zimowy 2023/2024,\nSGH Szkoła Główna Handlowa w Warszawie\nPodstawowe informacje znajdziesz w sylabusie.\nCiekawe książki i strony internetowe zamieszczone zostały w zakładce książki. Jeśli chciał(a)byś coś dodać prześlij informację przez MS teams."
  },
  {
    "objectID": "index.html#kalendarz",
    "href": "index.html#kalendarz",
    "title": "Informacje ogólne",
    "section": "Kalendarz",
    "text": "Kalendarz\n\nWykład\nWykład jest realizowany w trybie hybrydowym. Jest on NIEOBOWIĄZKOWY i odbywa się w sali C5D.\n\n02-10-2023 (poniedziałek) 11:40-13:20 -  Wykład 1 \n\nHistoria klasycznego i kwantowego komputera i jego zastosowania. Efekty kwantowe wykorzystywane do przyśpieszenia obliczeń.\nRealizacja:\n\nZna i rozumie koncepcje działania komputera klasycznego i kwantowego\nRozumie potrzebę i możliwości zastosowania komputerów kwantowych\nformułuje problem biznesowy wraz z jego informatycznym rozwiązaniem\nuzupełniania wiedzę teoretyczną jak i praktyczną, w zakresie teorii, programowania, modelowania, nowych technologii informatycznych z wykorzystaniem kwantowego uczenia maszynowego\n\n\n09-10-2023 (poniedziałek) 11:40-13:20 -  Wykład 2 \n\nKlasyczne bramki logiczne - algebra Boola, szyfrowanie\nRealizacja:\n\nZna i rozumie koncepcje działania komputera klasycznego i kwantowego\nRozumie potrzebę i możliwości zastosowania komputerów kwantowych\n\n\n16-10-2023 (poniedziałek) 11:40-13:20 -  Wykład 3 \n\nPrzestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów\n\n23-10-2023 (poniedziałek) 11:40-13:20 -  Wykład 4 \n\nKwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych\nRealizacja:\n\nPotrafi stworzyć proste algorytmy z wykorzystaniem kwantowych bramek logicznych\n\n\n30-10-2023 (poniedziałek) 11:40-13:20 -  Wykład 5 \n\nDZIEŃ WOLNY\nKwantowy Machine Learning w biznesie - metody i implementacje\n\n\nLaboratoria\nWszystkie laboratoria odbywają się w sali C5D.\n\n06-11-2023 (poniedziałek) 11:40-13:20 - Lab1\n\nPrzygotowanie środowiska programistycznego python z wykorzystaniem narzędzia Docker\n\n13-11-2023 (poniedziałek) 11:40-13:20 - Lab2\n\nKwantowe bity z wykorzystaniem biblioteki IBM Qiskit i Pennylane\n\n20-11-2023 (poniedziałek) 11:40-13:20 - Lab3\n\nJedno - kubitowe bramki logiczne\n\n27-11-2023 (poniedziałek) 11:40-13:20 - Lab4\n\nWielokubitowe bramki logiczne\n\n04-12-2023 (poniedziałek) 11:40-13:20 - Lab5\n\nAlgorytm faktoryzacji Shora, przeszukiwanie wg algorytmu Grovera.\n\n11-12-2023 (poniedziałek) 11:40-13:20 - Lab6\n\nKlasyczny i kwantowy perceptron - realizacja w bibliotece qiskit\n\n18-12-2023 (poniedziałek) 11:40-13:20 - Lab7\n\nVariational quantum classifiers - klasyfikacja danych iris\n\n08-01-2024 (poniedziałek) 11:40-13:20 - Lab8\n\nklasyfikacja danych MNIST z wykorzystaniem biblioteki PyTorch Quantum\n\n15-01-2024 (poniedziałek) 11:40-13:20 - Lab9\n\nAlgorytm qPCA z wykorzystaniem do modelowania cen instrumentów finansowych\n\n22-01-2024 (poniedziałek) 11:40-13:20 - Lab10\n\nRealizacje kwantowych sztucznych sieci neuronowych - wprowadzenie"
  },
  {
    "objectID": "index.html#technologie",
    "href": "index.html#technologie",
    "title": "Informacje ogólne",
    "section": "Technologie",
    "text": "Technologie\nUczestnicząc w zajęciach musisz opanować i przynajmniej w podstawowym zakresie posługiwać się następującymi technologiami informatycznymi:\n\nGIT\nPython, Jupyter notebook, Jupyter lab, Colab\nDocker"
  },
  {
    "objectID": "index.html#qpoland",
    "href": "index.html#qpoland",
    "title": "Informacje ogólne",
    "section": "QPoland",
    "text": "QPoland\nQPoland jest cześcią międzynarodowej sieci QWorld.\n\nQWorld is a global network of individuals, groups, and communities collaborating on education and implementation of quantum technologies and research activities."
  },
  {
    "objectID": "other/pennylane.html",
    "href": "other/pennylane.html",
    "title": "Pennylane",
    "section": "",
    "text": "Codebook\nPennyLane Challenges"
  },
  {
    "objectID": "sylabus.html",
    "href": "sylabus.html",
    "title": "Sylabus",
    "section": "",
    "text": "Nazwa przedmiotu: Wstęp do kwantowego uczenia maszynowego\nJednostka: SGH Szkoła Główna Handlowa w Warszawie\nKod przedmiotu: 232530-D, 232530-S\nPunkty ECTS: 3\nJęzyk prowadzenia: polski\nPoziom przedmiotu: średnio-zaawansowany\nProwadzący: Sebastian Zając, sebastian.zajac@sgh.waw.pl\nWebsite: https://sebkaz-teaching.github.io/intro_to_qml/"
  },
  {
    "objectID": "sylabus.html#cel-przedmiotu",
    "href": "sylabus.html#cel-przedmiotu",
    "title": "Sylabus",
    "section": "Cel Przedmiotu",
    "text": "Cel Przedmiotu\nJeszcze do niedawna rozwój technologiczny oparty był na zmniejszaniu rozmiaru tranzystorów i zwiększaniu mocy obliczeniowej procesorów. Ze względu na fizyczne aspekty natury proces ten, od pewnego momentu, musi uwzględniać ograniczenia fizyki kwantowej. Przyszłość może jednak wykorzystać inne narzędzia, których możliwości wykraczają poza klasyczne moce obliczeniowe. Mimo, iż konstrukcja komputerów kwantowych to wciąż etap inżynierski, to okazuje się, że można już wskazać i wykorzystać je do tworzenia algorytmów, które można wykorzystać w dziedzinie uczenia maszynowego. Wykorzystanie algorytmów kwantowych pozwala zmniejszyć czas przetwarzania dużej ilości danych, a tym samym rozszerza możliwości przetwarzania i modelowania danych. Przedstawione na zajęciach biblioteki - IBM qiskit czy Pennylane (python) pozwalają na prostą i szybką konstrukcje dowolnego algorytmu kwantowego. Algorytmy te, jak np. algorytm Grovera wykorzystać można do wielu problemów obliczeniowych uczenia maszynowego bądź do konstrukcji kwantowych sieci neuronowych."
  },
  {
    "objectID": "sylabus.html#program-przedmiotu",
    "href": "sylabus.html#program-przedmiotu",
    "title": "Sylabus",
    "section": "Program przedmiotu",
    "text": "Program przedmiotu\n\nEfekty kształcenia\nWiedza:\n\n\nZna i rozumie koncepcje działania komputera klasycznego i kwantowego\nZna metody kwantowego uczenia maszynowego możliwe do wykorzystania w biznesie\nRozumie potrzebę i możliwości zastosowania komputerów kwantowych\n\n\nUmiejętności:\n\n\nPotrafi stworzyć proste algorytmy z wykorzystaniem kwantowych bramek logicznych\nUmie wykorzystać biblioteki pythonowe do generowania kodów obliczeń kwantowych\nPotrafi wykorzystać metody nadzorowane wykorzystywane w kwantowym uczeniu maszynowym\nPotrafi wykorzystać metody nienadzorowane wykorzystywane w kwantowym uczeniu maszynowym\nUmie stworzyć prostą kwantową sieć neuronową\n\n\nKompetencje społeczne:\n\n\nformułuje problem biznesowy wraz z jego informatycznym rozwiązaniem\nuzupełniania wiedzę teoretyczną jak i praktyczną, w zakresie teorii, programowania, modelowania, nowych technologii informatycznych z wykorzystaniem kwantowego uczenia maszynowego"
  },
  {
    "objectID": "sylabus.html#realizacja-przedmiotu",
    "href": "sylabus.html#realizacja-przedmiotu",
    "title": "Sylabus",
    "section": "Realizacja przedmiotu",
    "text": "Realizacja przedmiotu\n\negzamin testowy: 40%\nkolokwium: 20%\nreferaty/eseje: 40%"
  },
  {
    "objectID": "sylabus.html#literatura",
    "href": "sylabus.html#literatura",
    "title": "Sylabus",
    "section": "Literatura",
    "text": "Literatura\n\nM. Schuld, F. Petruccione - Supervised Learning with Quantum Computers, Quantum Science and Technology. Springer 2018 https://doi.org/10.1007/978-3-319-96424-9\nC. Bernhardt - Obliczenia kwantowe dla każdego, Wydawnictwo Naukowe PWN 2020\nE. R. Johnston, N. Harrigan, M.Gimeno-Segovia - Komputer kwantowy.Programowanie, algorytmy, kod. Helion 2020\nS. Zajac - Modelowanie dla Biznesu. Analiza danych w czasie rzeczywistym. Oficyna Wydawnicza SGH. 2021\nA. K. Bishwas, A. Nani, V. Palade “Quantum Supervised Clustering Algorithm for Big Data” 2018- 3rd International Conference for Convergence in Technology.\nC. Ciliberto er al. “Statistical limits of supervised quantum learning” Physical Review A 102. 4. 2020\nN Wiebe, A. Kapoor, K M. Svore “Quantum perceptron models” NIPS’16 Procedings of the 30th Internationa Conference on Neural information processing Systems. Vol. 29. 2016"
  },
  {
    "objectID": "sylabus.html#literatura-uzupełniająca",
    "href": "sylabus.html#literatura-uzupełniająca",
    "title": "Sylabus",
    "section": "Literatura uzupełniająca",
    "text": "Literatura uzupełniająca\n\nMichael A. Nielsen & Isaac L. Chuang - Quantum Computation and Quantum Information, Cambridge University Press, 2010\nK. Przanowski, S. Zając - Modelowanie dla Biznesu. Metody Machine learning, Modele portfela consumer finance, modelek rekurencyjne analizy przeżycia, modele scoringowe. Oficyna Wydawnicza SGH. 2020\nE. Frątczak - Modelowanie dla Biznesu. Regresja Logistyczna, Regresja Poissona, Survival Data Mining, CRM, Credit Scoring. Oficyna Wydawnicza SGH. 2019"
  },
  {
    "objectID": "ksiazki.html",
    "href": "ksiazki.html",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Chris Bernhardt, Obliczenia kwantowe dla każdego. PWN 2020\n\n\nWyjaśnienie jak to działa w obliczeniach kwantowych.\n\n\nMichel Le Bellac, Wstęp do informatyki kwantowej. PWN 2011\n\n\nTrudniejsza, dużo matematyki i fizyki.\n\n\nThomas G. Wong, Introduction to Classical and Quantum Computing. Rooted Grove 2022.\n\n\nBardzo dobra!, dużo przykładów, dużo ciekawych informacji wyjaśnianych bardzo szczegółowo.\n\n\nA. Jacquier, O. Kondratyev, Quantum Machine Learning and Optimisation in Finance. On the Road to Quantum Advantage.\nP. Gawron, M. Cholewa, … Rewolucja stanu. Fantastyczne wprowadzenie do informatyki kwantowej. Quantumz.io 2021\n\n\n\n\n\n\n\nL. Moroney, Sztuczna inteligencja i uczenie maszynowe dla programistów. Praktyczny przewodnik po sztucznej inteligencji. Helion 2021. Zobacz opis lub Kup e-book\nBruce, Bruce, Gedeck, Statystyka praktyczna w data science. Wydanie II. Helion. 2021."
  },
  {
    "objectID": "ksiazki.html#książki",
    "href": "ksiazki.html#książki",
    "title": "Książki i strony WWW",
    "section": "",
    "text": "Chris Bernhardt, Obliczenia kwantowe dla każdego. PWN 2020\n\n\nWyjaśnienie jak to działa w obliczeniach kwantowych.\n\n\nMichel Le Bellac, Wstęp do informatyki kwantowej. PWN 2011\n\n\nTrudniejsza, dużo matematyki i fizyki.\n\n\nThomas G. Wong, Introduction to Classical and Quantum Computing. Rooted Grove 2022.\n\n\nBardzo dobra!, dużo przykładów, dużo ciekawych informacji wyjaśnianych bardzo szczegółowo.\n\n\nA. Jacquier, O. Kondratyev, Quantum Machine Learning and Optimisation in Finance. On the Road to Quantum Advantage.\nP. Gawron, M. Cholewa, … Rewolucja stanu. Fantastyczne wprowadzenie do informatyki kwantowej. Quantumz.io 2021\n\n\n\n\n\n\n\nL. Moroney, Sztuczna inteligencja i uczenie maszynowe dla programistów. Praktyczny przewodnik po sztucznej inteligencji. Helion 2021. Zobacz opis lub Kup e-book\nBruce, Bruce, Gedeck, Statystyka praktyczna w data science. Wydanie II. Helion. 2021."
  },
  {
    "objectID": "ksiazki.html#strony-www",
    "href": "ksiazki.html#strony-www",
    "title": "Książki i strony WWW",
    "section": "Strony WWW",
    "text": "Strony WWW\n\nPeter Shor Wykład\n\n\nPakiety Python\n\nQiskit\nPennyLane\n\n\n\nPakiety Julia\n\nYao\nQAOA\n\n\n\nEdytory tekstu\n\nNotepad++\nSublime Text\nVisual Studio Code\n\n\n\nMarkdown\n\nMD\n\n\n\nFilmy\n\nWprowadzenie do obliczeń kwantowych\nQPoland, Bronze, Warsztaty z programowania komputerów kwantowych 2023"
  },
  {
    "objectID": "other/qiskitML.html",
    "href": "other/qiskitML.html",
    "title": "Qiskit Machine Learning",
    "section": "",
    "text": "dokumentacja\n\nQuantum Kernels (Quantum Support Vector Classifier, Quantum Support Vector Regressor)\nQuantum Neural Networks (Variational Quantum Classifier, Variational Quantum Regressor), fature map (ZZFeatureMap, ZFeatureMap, PauliFeatureMap) i ansatz (RealAmplitudes, EfficientSU2, ZZFeatureMap, ZFeatureMap, PauliFeatureMap). Posiada również konektor do PyTorcha.\n\nużywane do klasyfikacji (QSVC) i regresjii (QSVR). Pozwalają na używanie kwantowego uczenia maszynowego bez wiedzy o obliczeniach kwantowych.\n\n# instalacja \n!pip install --upgrade pip\n!pip install qiskit-machine-learning\n!pip install 'qiskit-machine-learning[torch]'\n!pip install 'qiskit-machine-learning[sparse]' \n# !pip install ipywidgets ipykernel\n\n\nimport qiskit.tools.jupyter\n\n%qiskit_version_table\n\nVersion Information\n\n\n\nSoftware\nVersion\n\n\nqiskit\nNone\n\n\nqiskit-terra\n0.25.2\n\n\nSystem information\n\n\nPython version\n3.10.12\n\n\nPython compiler\nClang 14.0.3 (clang-1403.0.22.14.1)\n\n\nPython build\nmain, Jul 28 2023 18:34:01\n\n\nOS\nDarwin\n\n\nCPUs\n8\n\n\nMemory (Gb)\n16.0\n\n\nSun Oct 15 20:37:42 2023 CEST"
  },
  {
    "objectID": "info.html",
    "href": "info.html",
    "title": "Narzędzia",
    "section": "",
    "text": "W terminalu (Windows CMD) wpisz\npython\nJeśli nie odnaleziono komendy uruchom polecenie:\npython3\nZwróć uwagę, aby Twoja wersja nie była niższa niż 3.X Aby wyjść z powłoki pythona użyj funkcji exit()\nPython 3.10.9 (main, Dec 15 2022, 17:11:09) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; exit()\n\n\npython3 -m venv &lt;name of env&gt;\n\nsource &lt;name of env&gt;/bin/activate\n# . env/bin/activate\n\n(venv)$ \nJak uruchomić środowisko pythona w systemie Windows.\nSzybka instalacja podstawowych bibliotek i jupyterlab.\npip install --no-cache --upgrade pip setuptools\n\npip install jupyterlab numpy pandas matplotlib scipy\n# jeśli masz plik requirements.txt z potrzebnymi bibliotekami\npip install -r requirements.txt\n# uruchom \njupyterlab\nW przeglądarce internetowej wpisz: localhost:8888\nPo ponownym uruchomieniu przejdź do katalogu w którym utworzyłeś środowisko, następnie uruchom środowisko i jupyterlab.\nsource &lt;name of env&gt;/bin/activate\njupyterlab\n\n\n\nKurs podstaw pythona Tomas Beuzen polecam.\nUtwórz konto na Kaggle, przejdź do zakładki Courses i przerób cały moduł Pythona. Zawiera on:\n\nwyrażenia i zmienne\nfunkcje\nwarunki i flow programu\nlisty\npętle\nstringi i słowniki\ndodawanie i używanie zewnętrznych bibliotek"
  },
  {
    "objectID": "info.html#python",
    "href": "info.html#python",
    "title": "Narzędzia",
    "section": "",
    "text": "W terminalu (Windows CMD) wpisz\npython\nJeśli nie odnaleziono komendy uruchom polecenie:\npython3\nZwróć uwagę, aby Twoja wersja nie była niższa niż 3.X Aby wyjść z powłoki pythona użyj funkcji exit()\nPython 3.10.9 (main, Dec 15 2022, 17:11:09) [Clang 14.0.0 (clang-1400.0.29.202)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n&gt;&gt;&gt; exit()\n\n\npython3 -m venv &lt;name of env&gt;\n\nsource &lt;name of env&gt;/bin/activate\n# . env/bin/activate\n\n(venv)$ \nJak uruchomić środowisko pythona w systemie Windows.\nSzybka instalacja podstawowych bibliotek i jupyterlab.\npip install --no-cache --upgrade pip setuptools\n\npip install jupyterlab numpy pandas matplotlib scipy\n# jeśli masz plik requirements.txt z potrzebnymi bibliotekami\npip install -r requirements.txt\n# uruchom \njupyterlab\nW przeglądarce internetowej wpisz: localhost:8888\nPo ponownym uruchomieniu przejdź do katalogu w którym utworzyłeś środowisko, następnie uruchom środowisko i jupyterlab.\nsource &lt;name of env&gt;/bin/activate\njupyterlab\n\n\n\nKurs podstaw pythona Tomas Beuzen polecam.\nUtwórz konto na Kaggle, przejdź do zakładki Courses i przerób cały moduł Pythona. Zawiera on:\n\nwyrażenia i zmienne\nfunkcje\nwarunki i flow programu\nlisty\npętle\nstringi i słowniki\ndodawanie i używanie zewnętrznych bibliotek"
  },
  {
    "objectID": "info.html#zacznij-korzystać-z-serwisu-github",
    "href": "info.html#zacznij-korzystać-z-serwisu-github",
    "title": "Narzędzia",
    "section": "Zacznij korzystać z serwisu GitHub",
    "text": "Zacznij korzystać z serwisu GitHub\n\n\n\nTekst na podstawie strony jak korzystać z serwisu github\nPracując nad projektem np. praca magisterska, (samodzielnie lub w zespole) często potrzebujesz sprawdzić jakie zmiany, kiedy i przez kogo zostały wprowadzone do projektu. W zadaniu tym świetnie sprawdza się system kontroli wersji czyli GIT.\nGit możesz pobrać i zainstalować jak zwykły program na dowolnym komputerze. Jednak najczęściej (małe projekty) korzysta się z serwisów z jakimś systemem git. Jednym z najbardziej rozpoznawanych jest GitHub dzięki któremu możesz korzystać z systemu git bez jego instalacji na swoim komputerze.\nW darmowej wersji serwisu GitHub swoje pliki możesz przechowywać w publicznych (dostęp mają wszyscy) repozytoriach.\nSkupimy się wyłącznie na darmowej wersji serwisu GitHub.\ngit --version\n\nStruktura GitHuba\nNa najwyższym poziomie znajdują się konta indywidualne (np http://github.com/sebkaz, bądź zakładane przez organizacje. Użytkownicy indywidualni mogą tworzyć repozytoria publiczne (public ) bądź prywatne (private).\nJeden plik nie powinien przekraczać 100 MB.\nRepo (skrót do repozytorium) tworzymy za pomocą Create a new repository. Każde repo powinno mieć swoją indywidualną nazwę.\n\n\nBranche\nGłówna (tworzona domyślnie) gałąź rapozytorium ma nazwę master.\n\n\nNajważniejsze polecnia do zapamiętania\n\nściąganie repozytorium z sieci\n\ngit clone https://adres_repo.git\n\nW przypadku githuba możesz pobrać repozytorium jako plik zip.\n\n\nTworzenie repozytorium dla lokalnego katalogu\n\n# tworzenie nowego katalogu\nmkdir datamining\n# przejście do katalogu\ncd datamining\n# inicjalizacja repozytorium w katalogu\ngit init\n# powinien pojawić się ukryty katalog .git\n# dodajmy plik\necho \"Info \" &gt;&gt; README.md\n\nPołącz lokalne repozytorium z kontem na githubie\n\ngit remote add origin https://github.com/&lt;twojGit&gt;/nazwa.git\n\nObsługa w 3 krokach\n\n# sprawdź zmiany jakie zostały dokonane\ngit status\n# 1. dodaj wszystkie zmiany\ngit add .\n# 2. zapisz bierzący stan wraz z informacją co zrobiłeś\ngit commit -m \" opis \"\n# 3. potem już zostaje tylko\ngit push origin master\nWarto obejrzeć Youtube course.\nCiekawe i proste wprowadzenie mozna znaleźć tutaj"
  },
  {
    "objectID": "info.html#zacznij-korzystać-z-dockera",
    "href": "info.html#zacznij-korzystać-z-dockera",
    "title": "Narzędzia",
    "section": "Zacznij korzystać z Dockera",
    "text": "Zacznij korzystać z Dockera\n\n\n\nW celu pobrania oprogramowania docker na swój system przejdź do strony.\nJeżli wszystko zainstalowało się prawidłowo wykonaj następujące polecenia:\n\nSprawdź zainstalowaną wersję\n\ndocker --version\n\nŚciągnij i uruchom obraz Hello World i\n\ndocker run hello-world\n\nPrzegląd ściągnietych obrazów:\n\ndocker image ls\n\ndocker images\n\nPrzegląd uruchomionych kontenerów:\n\ndocker ps \n\ndocker ps -all\n\nZatrzymanie uruchomionego kontenera:\n\ndocker stop &lt;CONTAINER ID&gt;\n\nUsunięcie kontenera\n\ndocker rm -f &lt;CONTAINER ID&gt;\nPolecam również krótkie intro"
  },
  {
    "objectID": "cwiczenia/parametrized_q_c.html",
    "href": "cwiczenia/parametrized_q_c.html",
    "title": "Parameterized Quantum Circuit",
    "section": "",
    "text": "from qiskit import QuantumCircuit, execute, Aer, QuantumRegister, ClassicalRegister\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\nParametryzowane algorytmy kwantowe, czyli takie w których realizujemy obwody przez bramki parametryzowane (liczbami) są podstawowym budulcem algorytmów kwantowego uczenia maszynowego. Bardzo często mozna się spotkać z innymi nazwami: parameterized trial states, variational forms, lub ansatzes.\nPonizszy przykład przedstawia obwód z dwoma bramkami parametryzowanymi jedną liczbą \\(\\theta\\). Do oznaczenia parametru wykorzystano obiekt Parameter.\nfrom qiskit.circuit import QuantumCircuit, Parameter\n\ntheta = Parameter('θ')\n\nqc = QuantumCircuit(2)\nqc.rz(theta, 0)\nqc.crz(theta, 0, 1)\nqc.draw('mpl')\nJezeli chcemy zastosować wiele parametrów dla róznych bramek mozemy uzyc klasy kilku obiektów na podstawie klasy Parameters lub zastosować klasę ParameterVector.\nfrom qiskit.circuit import ParameterVector\ntheta_list = ParameterVector('theta', length=2)\n\nqc = QuantumCircuit(2)\nqc.rz(theta_list[0], 0)\nqc.crz(theta_list[1], 0, 1)\nqc.draw('mpl')\nSkąd wziąć informacje jak powinny wyglądać obwody w zagadnieniach kwantowego uczenia maszynowego?\nW ogólności realizowane jest to w formie testowej sprwadz publikację.\nPrzetestujmy dwa parametryczne obwody i zobaczmy jakie mozliwosci kodowania stanów one reprezentują."
  },
  {
    "objectID": "cwiczenia/parametrized_q_c.html#entangling-capability",
    "href": "cwiczenia/parametrized_q_c.html#entangling-capability",
    "title": "Parameterized Quantum Circuit",
    "section": "Entangling capability",
    "text": "Entangling capability\nDrugą, wazną cechą obwodów jest mozliwosc wykorzystania splątania."
  },
  {
    "objectID": "cwiczenia/cw4.html",
    "href": "cwiczenia/cw4.html",
    "title": "Algorytmy kwantowe - przegląd",
    "section": "",
    "text": "Wyobraźmy sobie, ze ktoś ukrywa dwie monety w rękach. Poniewaz kazda moneta ma dwie strony (niezalezne) dwie ręcę mogą ukryć 4 mozliwe sytuacje. Jeśli w obu rękach mamy te same strony mozemy powiedziec o stałej funkcji, która przyjmuje lewą rękę a zwraca prawą. Jeśli wynik ulega zmianie mozemy powiedziec o funkcji zbalansowanej.\nW przypadku monet, nawet jeśli odsłonimy monetę w lewej ręce nie jesteśmy w stanie stwierdzić, bez sprawdzenia, co jest w prawej ręce. A teraz wyobraź sobie 100 takich rąk. Aby mieć pewność czy masz doczynienia z funkcją stałą musisz (czy chcesz czy nie) sprawdzić wszystkie mozliwości - wystarczy jedna róznica, aby funkcja była zbalansowana.\nCo powiesz jeśli stwierdzę, ze kwantowy komputer moze rozwiązać problem otwierając wszystkie ręcę za jednym razem?\nDla funkcji boolowskiej \\(f:\\{0,1\\} \\rightarrow \\{0, 1\\}\\) mówimy, ze \\(f\\) jest zbalansowana jeśli \\(f(0) \\neq f(1)\\) lub stała jeśli \\(f(0) = f(1)\\).\n\\[\nf(0) = 0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\\\\\nf(1) = 0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\\\\\n\\] Taka funkcja moze być reprezentowana jako macierz: \\[\nf = \\begin{pmatrix} 1 \\,\\, 1 \\\\0 \\,\\, 0 \\end{pmatrix}\n\\]\nJednak, aby była uzyteczna dla obliczeń kwantowych musi być odwracalna i unitarna.\nAby sprawdzić i jednoznacznie stwierdzić czy funkcja, którą się posługujemy jest stała czy zbalansowana w klasycznym przypadku musimy sprawdzić oba wyniki \\(f(0)\\) i \\(f(1)\\).\nBardzo często tego typu modelowanie (funkcję) nazywa się black box lub oracle.\nTworzymy dwa rejestry kwantowe - input \\(|x\\rangle\\) i output \\(|y\\rangle\\)\nDefiniujemy rejestr outputu jako wynik działania XOR na rejestrze inputu: \\[\nU_f: |x\\rangle ,|y\\rangle \\to |x\\rangle, |y \\oplus f(x)\\rangle\n\\] \\[\nU^{-1}_f: |x\\rangle, |y \\oplus f(x)\\rangle \\to |x\\rangle ,|y\\rangle\n\\]\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\nfrom qiskit.quantum_info import Statevector\nfrom numpy.random import randint\nimport numpy as np\nfrom qiskit.providers.aer import QasmSimulator\n%matplotlib inline\n\nKrok 1: tworzymy obwod kwantowy dla dwóch kubitów: - pierwszy w stanie 0 - drugi w stanie 1\n\n# krok 1 2 kubitowy circuit\nqc = QuantumCircuit(2,1)\nqc.i(0)\nqc.x(1)\nqc.draw(output='mpl')\n\n\n\n\nKrok 2: hadamard na oba kubity - tworzymy superpozycje aby działać na 4 stanach jednocześnie\n\n# krok 2 hadamard na oba kubity - tworzymy superpozycje aby działać na 4 stanach jednocześnie\n\nqc.h(0)\nqc.h(1)\nqc.draw(output='mpl')\n\n\n\n\n\nstate = Statevector(qc)\ndisplay(plot_bloch_multivector(state, reverse_bits=True))\n\n\n\n\nPo zastosowaniu bramek hadamarda, otrzymujemy: \\[ \\frac{1}{\\sqrt{2}}(|00\\rangle-|01\\rangle+|01\\rangle-|11\\rangle) ----&gt; Equation 1\\]\nZauwazmy ze drugi kubit jest w stanie - (\\(H|1\\rangle\\)), mozemy zdefiniować powyzsze rownanie jako:\n\\[ \\frac{(-1)^{f(0)}|0\\rangle+(-1)^{f(1)}|1\\rangle}{\\sqrt{2}}\\cdot{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}\\]\nJeśli \\(f\\) jest stała, wtedy \\(f(0)=0\\) i \\((-1)^0=1\\) oraz \\(f(1)=0\\)\notrzymujemy:\n\\[\\pm{\\frac{(|0\\rangle+|1\\rangle)}{\\sqrt{2}}}{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}\\]\nW przeciwnym przypadku (\\(f\\) jest zbalansowana): \\[\\pm{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}\\]\nDla stałej funkcji pierwszy kubit jest ustawiony jako: \\[{\\frac{(|0\\rangle+|1\\rangle)}{\\sqrt{2}}}\\] ponowne zastosowanie bramki H zwroci nam stan \\(|0\\rangle\\).\nAnalogicznie, dla zbalansowanej funkcji dostaniemy stan \\(|1\\rangle\\).\nNa podstawie tej informacji, mierząc TYLKO pierwszy kubit (po zastosowaniu bramki H) otrzymamy stan \\(|0\\rangle\\) albo \\(|1\\rangle\\) co daje jednoznaczą odpowiedź z jaką funkcją mamy do czynienia.\nNastępnym krokiem jest zastosowanie bramki działającej na dwóch kubitach. \\[\nU_f: \\ket{x} ,\\ket{y} \\to \\ket{x}, \\ket{y \\oplus f(x)}\n\\]\n\nqc.cx(0,1)\nqc.draw(output='mpl')\n\n\n\n\n\nstate = Statevector(qc)\ndisplay(plot_bloch_multivector(state, reverse_bits=True))\n\n\n\n\n\nqc.h(0)\nqc.h(1)\nqc.draw(output='mpl')\n\n\n\n\n\nstate = Statevector(qc)\ndisplay(plot_bloch_multivector(state, reverse_bits=True))\n\n\n\n\n\nfrom qiskit import execute, Aer\n\nqc.measure(0,0)\ndisplay(qc.draw(output='mpl'))\n\nbackend = Aer.get_backend('qasm_simulator')\nresult = execute(qc, backend, shots=1000).result()\ncounts = result.get_counts(qc)\n\n\n\n\n\n\nfrom qiskit.visualization import plot_histogram\nplot_histogram(counts)"
  },
  {
    "objectID": "cwiczenia/cw4.html#deutsch-algorithm",
    "href": "cwiczenia/cw4.html#deutsch-algorithm",
    "title": "Algorytmy kwantowe - przegląd",
    "section": "",
    "text": "Wyobraźmy sobie, ze ktoś ukrywa dwie monety w rękach. Poniewaz kazda moneta ma dwie strony (niezalezne) dwie ręcę mogą ukryć 4 mozliwe sytuacje. Jeśli w obu rękach mamy te same strony mozemy powiedziec o stałej funkcji, która przyjmuje lewą rękę a zwraca prawą. Jeśli wynik ulega zmianie mozemy powiedziec o funkcji zbalansowanej.\nW przypadku monet, nawet jeśli odsłonimy monetę w lewej ręce nie jesteśmy w stanie stwierdzić, bez sprawdzenia, co jest w prawej ręce. A teraz wyobraź sobie 100 takich rąk. Aby mieć pewność czy masz doczynienia z funkcją stałą musisz (czy chcesz czy nie) sprawdzić wszystkie mozliwości - wystarczy jedna róznica, aby funkcja była zbalansowana.\nCo powiesz jeśli stwierdzę, ze kwantowy komputer moze rozwiązać problem otwierając wszystkie ręcę za jednym razem?\nDla funkcji boolowskiej \\(f:\\{0,1\\} \\rightarrow \\{0, 1\\}\\) mówimy, ze \\(f\\) jest zbalansowana jeśli \\(f(0) \\neq f(1)\\) lub stała jeśli \\(f(0) = f(1)\\).\n\\[\nf(0) = 0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\\\\\nf(1) = 0 = \\begin{pmatrix} 1 \\\\ 0 \\end{pmatrix}\\\\\n\\] Taka funkcja moze być reprezentowana jako macierz: \\[\nf = \\begin{pmatrix} 1 \\,\\, 1 \\\\0 \\,\\, 0 \\end{pmatrix}\n\\]\nJednak, aby była uzyteczna dla obliczeń kwantowych musi być odwracalna i unitarna.\nAby sprawdzić i jednoznacznie stwierdzić czy funkcja, którą się posługujemy jest stała czy zbalansowana w klasycznym przypadku musimy sprawdzić oba wyniki \\(f(0)\\) i \\(f(1)\\).\nBardzo często tego typu modelowanie (funkcję) nazywa się black box lub oracle.\nTworzymy dwa rejestry kwantowe - input \\(|x\\rangle\\) i output \\(|y\\rangle\\)\nDefiniujemy rejestr outputu jako wynik działania XOR na rejestrze inputu: \\[\nU_f: |x\\rangle ,|y\\rangle \\to |x\\rangle, |y \\oplus f(x)\\rangle\n\\] \\[\nU^{-1}_f: |x\\rangle, |y \\oplus f(x)\\rangle \\to |x\\rangle ,|y\\rangle\n\\]\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit, execute, Aer\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\nfrom qiskit.quantum_info import Statevector\nfrom numpy.random import randint\nimport numpy as np\nfrom qiskit.providers.aer import QasmSimulator\n%matplotlib inline\n\nKrok 1: tworzymy obwod kwantowy dla dwóch kubitów: - pierwszy w stanie 0 - drugi w stanie 1\n\n# krok 1 2 kubitowy circuit\nqc = QuantumCircuit(2,1)\nqc.i(0)\nqc.x(1)\nqc.draw(output='mpl')\n\n\n\n\nKrok 2: hadamard na oba kubity - tworzymy superpozycje aby działać na 4 stanach jednocześnie\n\n# krok 2 hadamard na oba kubity - tworzymy superpozycje aby działać na 4 stanach jednocześnie\n\nqc.h(0)\nqc.h(1)\nqc.draw(output='mpl')\n\n\n\n\n\nstate = Statevector(qc)\ndisplay(plot_bloch_multivector(state, reverse_bits=True))\n\n\n\n\nPo zastosowaniu bramek hadamarda, otrzymujemy: \\[ \\frac{1}{\\sqrt{2}}(|00\\rangle-|01\\rangle+|01\\rangle-|11\\rangle) ----&gt; Equation 1\\]\nZauwazmy ze drugi kubit jest w stanie - (\\(H|1\\rangle\\)), mozemy zdefiniować powyzsze rownanie jako:\n\\[ \\frac{(-1)^{f(0)}|0\\rangle+(-1)^{f(1)}|1\\rangle}{\\sqrt{2}}\\cdot{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}\\]\nJeśli \\(f\\) jest stała, wtedy \\(f(0)=0\\) i \\((-1)^0=1\\) oraz \\(f(1)=0\\)\notrzymujemy:\n\\[\\pm{\\frac{(|0\\rangle+|1\\rangle)}{\\sqrt{2}}}{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}\\]\nW przeciwnym przypadku (\\(f\\) jest zbalansowana): \\[\\pm{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}{\\frac{(|0\\rangle-|1\\rangle)}{\\sqrt{2}}}\\]\nDla stałej funkcji pierwszy kubit jest ustawiony jako: \\[{\\frac{(|0\\rangle+|1\\rangle)}{\\sqrt{2}}}\\] ponowne zastosowanie bramki H zwroci nam stan \\(|0\\rangle\\).\nAnalogicznie, dla zbalansowanej funkcji dostaniemy stan \\(|1\\rangle\\).\nNa podstawie tej informacji, mierząc TYLKO pierwszy kubit (po zastosowaniu bramki H) otrzymamy stan \\(|0\\rangle\\) albo \\(|1\\rangle\\) co daje jednoznaczą odpowiedź z jaką funkcją mamy do czynienia.\nNastępnym krokiem jest zastosowanie bramki działającej na dwóch kubitach. \\[\nU_f: \\ket{x} ,\\ket{y} \\to \\ket{x}, \\ket{y \\oplus f(x)}\n\\]\n\nqc.cx(0,1)\nqc.draw(output='mpl')\n\n\n\n\n\nstate = Statevector(qc)\ndisplay(plot_bloch_multivector(state, reverse_bits=True))\n\n\n\n\n\nqc.h(0)\nqc.h(1)\nqc.draw(output='mpl')\n\n\n\n\n\nstate = Statevector(qc)\ndisplay(plot_bloch_multivector(state, reverse_bits=True))\n\n\n\n\n\nfrom qiskit import execute, Aer\n\nqc.measure(0,0)\ndisplay(qc.draw(output='mpl'))\n\nbackend = Aer.get_backend('qasm_simulator')\nresult = execute(qc, backend, shots=1000).result()\ncounts = result.get_counts(qc)\n\n\n\n\n\n\nfrom qiskit.visualization import plot_histogram\nplot_histogram(counts)"
  },
  {
    "objectID": "cwiczenia/cw4.html#szyfrowanie",
    "href": "cwiczenia/cw4.html#szyfrowanie",
    "title": "Algorytmy kwantowe - przegląd",
    "section": "Szyfrowanie",
    "text": "Szyfrowanie\n\nBB84 - Kawantowa dystrybucja klucza\nKwantowa dystrybucja klucza z ang. Quantum Key Distribution – QKD.\nPytania nad którymi warto się zastanowić:\n\nJak dzielić klucz bez jego fizycznego wysyłania do odbiorcy przez sieć?\nJak zakodować tekst z uzyciem klucza (To juz znamy z XOR)?\nDlaczego QKD działa?\nJak zasymulować algorytm BB84 w qiskit?\n\nRozwazmy klasyczną Alicję i Boba, którzy chcą podzielić się poufną informacją. Zawartość przekazywanej wiadomości nie ma znaczenia.\n\n\nTworzenie klucza\nAlicja i Bob wymieniają się inforamcją o bazach i patrzą tylko na te kubity dla których pomiary wykonywane były w tej samej bazie. Prawdopodobieństwo, ze ich bazy się zgadzają wynosi 1/2.\n\nq = QuantumRegister(10)\nc = ClassicalRegister(10)\n\nqc = QuantumCircuit(q,c)\nqc.h(q)\nqc.barrier()\nqc.measure(q,c)\nqc.draw('mpl')\n\n\n\n\n\njob = execute(qc, Aer.get_backend('qasm_simulator'), shots=1)\ncounts = job.result().get_counts()\ncounts\n\n{'0111000101': 1}\n\n\n\nwiadomosc = list(counts)[0]\nwiadomosc_odw = wiadomosc[::-1]\n\nMoze przekazać je bezpośrednio do Boba “kablem”. Jednak w trakcie przekazywania informacji moze przejąć ją kazdy (Eve), kto tylko podłączy się “gdzieś w środku”. Przejmie bity i ich kopię prześle do Boba.\nPoniewaz znamy juz zasady kwantowego generowania obwodów zobaczmy czy dodanie bramki hadamarda cos zmieni. Alicja po wygenerowaniu losowej informacji przetwarza kazdy pojedynczy bit bramką Hadamarda. Bob podczas odczytu korzysta z faktu, iz ponowne zastosowanie bramki Hadamarda pozwoli odzyskać zakodowany bit.\n\nfrom random import randrange\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer\n\nq = QuantumRegister(10)\nc = ClassicalRegister(10)\n\nqc = QuantumCircuit(q,c)\n\nfor i, bit in enumerate(wiadomosc_odw):\n    if bit == '1':\n        qc.x(q[i])\n    else:\n        qc.id(q[i])\n\nqc.h(q)\nqc.barrier()\n\nqc.h(q)\nqc.barrier()\n\nqc.measure(q,c)\ndisplay(qc.draw('mpl'))\n\njob = execute(qc, Aer.get_backend('qasm_simulator'), shots=1)\ncounts = job.result().get_counts()\nprint(f\"Alicja: {wiadomosc}, Bob: {counts}\")\n\n\n\n\nAlicja: 0111000101, Bob: {'0111000101': 1}\n\n\nSkoro Bob w prosty sposób moze odzyskać informację Eve równiez moze zastosować analogiczny proces. Najpierw zastosuje bramkę H, odczyta informację i wygeneruje kopię informacji klasycznej przemnozoną przez bramki Hadamarda. Bob nadal odbierze prawidłową inforamcję.\nCzy istnieje jakaś mozliwosc zabezpieczenia sie przed odzyskaniem informacji przez Eve? Pokazaliśmy właśnie, ze sama bramka H nie wystarczy.\nPomysł Alicji jest następujący:\n\nZastosujmy bramki hadamarda do losowo wybranych bitów informacji.\n\nCzy widzisz analogię z losowaniem bazy ??\nPostępując w ten sposób Eve nie ma mozliwosci zdecydowac dla których bitów powinna zastosować H a dla ktorych nie. A to znaczy, ze rowniez nie ma mozliwosci wysłać skopiowanej informacji dla Boba. Stanu kubitu nie da się sklonować.\nPytanie co ma zrobić Bob. Przekazanie informacji, które bity zostały potraktowane bramką H, w sposób klasyczny nie ma sensu.\nOdpowiedzią jest schemat znany jako BB84 zaproponowany przez Chales’a Bennett’a i Gilles’a Brassard’a w 1984.\nZałózmy, ze kazdy (Alicja i Bob) mają własne generatory losowego przypisywania bramek H.\n\nq = QuantumRegister(10)\nc = ClassicalRegister(10)\n\nqc = QuantumCircuit(q,c)\n# Alicja \nfor i, bit in enumerate(wiadomosc_odw):\n    if bit == '1':\n        qc.x(q[i])\n    else:\n        qc.id(q[i])\n\nfor i in range(10):\n    if randrange(2) == 0:\n        qc.h(q[i])\n\nqc.barrier()\n# Bob\nbob_pattern = []\nfor i in range(10):\n    if randrange(2) == 0:\n        qc.h(q[i])\n        bob_pattern.append('H')\n    else:\n        bob_pattern.append('-')\nqc.barrier()\n\nqc.measure(q,c)\ndisplay(qc.draw('mpl'))\n\njob = execute(qc, Aer.get_backend('qasm_simulator'), shots=1)\ncounts = job.result().get_counts()\nprint(f\"Alicja: {wiadomosc}, Bob: {counts}\")\nprint(\"bob's hadamard pattern\",bob_pattern)\n\n\n\n\nAlicja: 0111000101, Bob: {'0111000101': 1}\nbob's hadamard pattern ['H', '-', 'H', 'H', 'H', '-', '-', '-', '-', '-']\n\n\nJakie mozliwosci się pojawiają\n\nOboje sosują H do swoich bitów albo oboje ich nie stosują - dzięki temu Bob odzyskuje prawidłowy Bit.\nJedno stosuje a drugie nie stosuje bramki H. Tutaj niezaleznie, od opcji Bob zawsze zmierzy losowo 0 lub 1.\n\nPrawdopodobieństwo, ze oboje wybrali to samo = \\(1/2\\)\nTrochę inne podejście:\nAlicja genruje dwa losowe stringi bitowe (zawierają tylko 0 i 1). - pierwszy string koduje dwie bazy: 0 to baza obliczeniowa a 1 to baza Hadamarda. - drugi koduje stany kubitów: w bazie hadamarda 0 to stan “+” a 1 to stan “-”, w bazie obliczeniowej – wiadomo.\nAlicja przesyła do Boba 10 kubitów.\n\nfrom qiskit import QuantumCircuit, execute, Aer\nfrom qiskit.visualization import plot_histogram, plot_bloch_multivector\nfrom numpy.random import randint\nimport numpy as np\nfrom qiskit.providers.aer import QasmSimulator\n%matplotlib inline\n\n\nnum_qubits = 10 \nalice_basis = np.random.randint(2, size=num_qubits)\nalice_state = np.random.randint(2, size=num_qubits)\nbob_basis = np.random.randint(2, size=num_qubits)\n\nprint(f\"Alice's State:\\t {np.array2string(alice_state)}\")\nprint(f\"Alice's Bases:\\t {np.array2string(alice_basis)}\")\nprint(f\"Bob's Bases:\\t {np.array2string(bob_basis)}\")\n\nAlice's State:   [1 0 1 0 0 0 0 1 0 1]\nAlice's Bases:   [0 1 1 1 1 1 0 0 1 1]\nBob's Bases:     [0 0 1 0 0 1 0 0 0 0]\n\n\n\nzawsze gdy chcemy przeslac 1 w kubicie alicja aplikuje bramkę X do odpowiedniego kubitu. Dla 0 nie musi podejmować zadnego działania (lub id).\nJeśli ma zakodować coś w bazie Hadamarda uzywa bramki Hadamarda na odpowiedni kubit\nwysyła przygotowane kubity do Boba\nBob mierzy kubity zgodnie z przygotowanym przez siebie stringiem baz. Jeśli ma zmierzyć coś w bazie Hadamarda aplikuje bramkę H. Jeśli w bazie obliczeniowej nie robi niczego.\n\nfilm\n\ndef bb84_circuit(state, basis, measurement_basis):\n   \n    #state: array of 0s and 1s denoting the state to be encoded\n    #basis: array of 0s and 1s denoting the basis to be used for encoding\n                #0 -&gt; Computational Basis\n                #1 -&gt; Hadamard Basis\n    #meas_basis: array of 0s and 1s denoting the basis to be used for measurement\n                #0 -&gt; Computational Basis\n                #1 -&gt; Hadamard Basis\n    \n    num_qubits = len(state)\n    \n    circuit = QuantumCircuit(num_qubits)\n\n    # Sender prepares qubits\n    for i in range(len(basis)):\n        if state[i] == 1:\n            circuit.x(i)\n        if basis[i] == 1:\n            circuit.h(i)\n   \n\n    # Measuring action performed by Bob\n    for i in range(len(measurement_basis)):\n        if measurement_basis[i] == 1:\n            circuit.h(i)\n\n       \n    circuit.measure_all()\n    \n    return circuit\n\n\ncircuit = bb84_circuit(alice_state, alice_basis, bob_basis)\nkey = execute(circuit.reverse_bits(),backend=QasmSimulator(),shots=1).result().get_counts().most_frequent()\nencryption_key = ''\nfor i in range(num_qubits):\n    if alice_basis[i] == bob_basis[i]:\n         encryption_key += str(key[i])\nprint(f\"Key: {encryption_key}\")\n\nKey: 11001\n\n\nOther, a nice version from book\n\nimport random\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, Aer, execute\n\nNUMBER_OF_CIRCUITS = 100\nDOES_EVE_EXIST = True\nCHECK_MARK = u'\\u2713'\n\ndef create_circuits(how_many, does_eve_exist):\n    circuits = []\n    for i in range(how_many):\n        circuits.append(make_new_circuit(does_eve_exist))\n    return circuits\n\ndef make_new_circuit(eve_exists):\n    circ = create_registers(eve_exists)\n    alice_q = circ.qubits[0]\n    bob_q = circ.qubits[1]\n    bob_c = circ.clbits[0]\n    circ = setup_alice(circ)\n    circ.swap(alice_q, bob_q)\n    if eve_exists:\n        circ = setup_eve(circ)\n    circ = setup_bob(circ)\n    return circ\n\ndef create_registers(eve_exists):\n    alice_q = QuantumRegister(1, 'alice_q')\n    bob_q = QuantumRegister(1, 'bob_q')\n    bob_c = ClassicalRegister(1, 'bob_c')\n    if eve_exists:\n        eve_c = ClassicalRegister(1, 'eve_c')\n        circ = QuantumCircuit(alice_q, bob_q, bob_c, eve_c)\n    else:\n        circ = QuantumCircuit(alice_q, bob_q, bob_c)\n    return circ\n\n\ndef setup_alice(circ):\n    alice_q = circ.qubits[0]\n    if random.getrandbits(1):\n        circ.x(alice_q)\n    if random.getrandbits(1):\n        circ.h(alice_q)\n    return circ\n\ndef setup_bob(circ):\n    bob_q = circ.qubits[1]\n    bob_c = circ.clbits[0]\n    if random.getrandbits(1):\n        circ.h(bob_q)\n    circ.measure(bob_q, bob_c)\n    return circ\n\ndef setup_eve(circ):\n    bob_q = circ.qubits[1]\n    eve_c = circ.clbits[1]\n    circ.barrier()\n    circ.measure(bob_q, eve_c)\n    circ.barrier()\n    return circ\n\ndef run_the_job(circuits):\n    device = Aer.get_backend('qasm_simulator')\n    job = execute(circuits, backend=device, shots=1, memory=True)\n    return job.result()\n\ndef print_alice_bits(circuits):\n    print('alice bits: ', end='')\n    for circ in circuits:\n        bit = 1 if 'x' in circ.count_ops() else 0\n        print(bit, end='')\n    print('')\n\ndef print_bob_bits(circuits, result):\n    print('bob bits  : ', end='')\n    for circ in circuits:\n        memory = result.get_memory(circ)\n        print(bob_bit_value(circ, memory), end='')\n    print('')\n\ndef bob_bit_value(circ, memory):\n    return memory[0][0]\n\ndef had_agreement(circ):\n    gate_counts = circ.count_ops()\n    return not ('h' in gate_counts and gate_counts['h'] == 1)\n\ndef print_had_agreements(circuits):\n    number_of_agreements = 0\n    print('hads agree? ', end='')\n    for circ in circuits:\n        if had_agreement(circ):\n            print(CHECK_MARK, end='')\n            number_of_agreements += 1\n        else:\n            print(' ', end='')\n    print('')\n    return number_of_agreements\n\ndef print_bit_agreements(circuits, result,number_of_agreements):\n    number_tested = 0\n    is_eve_detected = False\n    i = 0\n    print('bits agree? ', end='')\n    while number_tested &lt; number_of_agreements // 2:\n        if had_agreement(circuits[i]):\n            if bit_value_agreement(circuits[i], result):\n                print(CHECK_MARK, end='')\n                number_tested += 1\n            else:\n                is_eve_detected = True\n                print('X')\n                break\n        else:\n            print(' ', end='')\n        i += 1\n    print()\n    return i, is_eve_detected\n\ndef bit_value_agreement(circ, result):\n    memory = result.get_memory(circ)\n    return alice_bit_value(circ) == int(\n        bob_bit_value(circ, memory))\n\ndef alice_bit_value(circ):\n    return 1 if 'x' in circ.count_ops() else 0\n\ndef print_key(circuits, number_of_circuits, how_many_for_testing):\n    print('key      :', end='')\n    for i in range(how_many_for_testing + 1):\n        print(' ', end='')\n    for i in range(i, NUMBER_OF_CIRCUITS):\n        if had_agreement(circuits[i]):\n            print(alice_bit_value(circuits[i]), end='')\n        else:\n            print(' ', end='')\n\n\ncircuits = create_circuits(NUMBER_OF_CIRCUITS, DOES_EVE_EXIST) # 1\nresult = run_the_job(circuits) # 2\nprint_alice_bits(circuits) # 3\nprint_bob_bits(circuits, result) # 4\nnumber_of_agreements = print_had_agreements(circuits) # 5\nhow_many_for_testing, is_eve_detected = print_bit_agreements(circuits, result,number_of_agreements) # 6\nif is_eve_detected:  # 7\n    print('INTRUDER ALERT!')\nelse:\n    print_key (circuits, NUMBER_OF_CIRCUITS, how_many_for_testing)\n\nalice bits: 0011110100001111000110101100101101111001111000001100100001100101110001111100110000010011111000010101\nbob bits  : 0011111110010011001101101000101001011000100000001101110111100001110000101100010010100111111011010001\nhads agree? ✓✓✓✓✓✓     ✓✓   ✓✓✓ ✓ ✓ ✓ ✓   ✓✓ ✓  ✓   ✓  ✓   ✓  ✓✓   ✓  ✓ ✓✓ ✓✓ ✓     ✓✓ ✓   ✓       ✓✓ ✓ ✓✓✓ ✓✓✓✓\nbits agree? ✓✓✓✓✓✓     X\n\nINTRUDER ALERT!"
  },
  {
    "objectID": "cwiczenia/cw4.html#kwantowa-teleportacja",
    "href": "cwiczenia/cw4.html#kwantowa-teleportacja",
    "title": "Algorytmy kwantowe - przegląd",
    "section": "Kwantowa teleportacja",
    "text": "Kwantowa teleportacja\nQuantum teleportation czyli kwantowa teleportacja to technika przekazu informacji (kwantowej) między wysyłającym i odbierającym. Jak poprzednio mozemy przyjąć, ze Alicja wysyła wiadomość do Boba. Informacja, którą chce przesłać Alicja to stan \\(|\\psi\\rangle=\\alpha |0\\rangle +\\beta |1\\rangle\\).\nZgodnie z twierdzeniem o zakazie klonowania, nie mozna wykonac dokładnej kopii dowolnego stanu kwantowego. Oznacza to, ze Alicja nie moze przygotować swojego stanu i go sklonować w celu wysłania go do Boba.\nUzyjemy dwóch klasycznych bitów informacji oraz splątanej pary kubitów. Ponadto trzeba pamiętać, ze w chwili kiedy Alicja wysyła swój Kubit niszczy jego stan u siebie.\n\nThe Quantum Teleportation Protocol\n\nimport numpy as np\nimport random\nfrom qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister, execute, Aer\nfrom qiskit.result import marginal_counts\n\nPotrzebujemy obwodu składającego się z 3 kubitów: 1. qubit Alicji 2. qubit splatany 1 (Eva-Alicja) 3. qubit splatany 2 (Eva-Bob)\ni 3 klasycznych rejestrów.\n\ndef create_registers():\n    alice_q = QuantumRegister(1, 'alice (q)')\n    eva_alice_q = QuantumRegister(1, 'eva/alice (q)')\n    eva_bob_q = QuantumRegister(1, 'eva/bob (q)')\n    bob_c = ClassicalRegister(3, 'bob (c)')\n    return QuantumCircuit(alice_q, eva_alice_q, eva_bob_q, bob_c)\n\n\nqc = create_registers()\nqc.draw('mpl')\n\n\n\n\nPrzygotujmy losowy stan Alicji, który prześlemy\n\ndef generate_amplitudes():\n    alpha = np.sqrt(random.uniform(0,1))\n    beta = np.sqrt(1 - alpha**2)\n    return alpha, beta\n\ngenerate_amplitudes()\n\n(0.4583992998876675, 0.8887463540642495)\n\n\nDodajemy bramki\n\ndef add_gates(circ, alpha, beta):\n    # stan alicji q0\n    circ.initialize([alpha, beta], 0)\n    circ.barrier()\n    # stan splątany q1 i q2\n    circ.h(1)\n    circ.cnot(1,2)\n    circ.barrier()\n    #  alicja stosuje bramki łacząc swoj kubit i otrzymany kubit od evy\n    circ.cnot(0,1)\n    circ.h(0)\n    circ.barrier()\n    # alicja mierzy kubity i przesyla info do Boba\n    circ.measure(0,0)\n    circ.measure(1,1)\n    # realizacja boba\n    with circ.if_test((1, 1)):\n        circ.x(2)\n    with circ.if_test((0, 1)):\n        circ.z(2)\n    circ.measure(2, 2)\n    return circ\n\n\nalpha, beta = generate_amplitudes()\nprint(f'alpha = {alpha:.4f},  beta = {beta:.4f}')\ncirc = create_registers()\ncirc = add_gates(circ, alpha, beta)\ndisplay(circ.draw('mpl', cregbundle=False))\n\nalpha = 0.6732,  beta = 0.7395\n\n\n\n\n\n\ndevice = Aer.get_backend(\"qasm_simulator\")\nshots = 1000\njob = device.run(circ, shots=shots)\nresult = job.result()\ncounts = result.get_counts(circ)\ncounts_m = marginal_counts(counts, [2])\nnumber_of_0s = counts_m.get('0')\nnumber_of_1s = counts_m.get('1')\nalpha = np.sqrt(number_of_0s / shots)\nbeta = np.sqrt(number_of_1s / shots)\nprint(\"stan =  ({:.4f}, {:.4f})\".format(alpha, beta))\n\nstan =  (0.6603, 0.7510)\n\n\nStep 4: Bob dekoder\nBob, który posiada kubit 3 q2 (wcześniej splątany) stosuje następujące bramki w zaleznosci od klasycznej informacji, którą orzymał:\n\\[00 \\to Identity \\]\n\\[01 \\to Apply 𝑋 gate \\]\n\\[ 10 \\to Apply Z gate \\]\n\\[ 11 \\to Apply 𝑍𝑋 gate \\]"
  },
  {
    "objectID": "cwiczenia/cw4.html#shor",
    "href": "cwiczenia/cw4.html#shor",
    "title": "Algorytmy kwantowe - przegląd",
    "section": "Shor",
    "text": "Shor\n\n\ndef initialize_qubits(given_circuit, n, m):\n\n    given_circuit.h(range(n))\n    given_circuit.x(n+m-1)\n\nfrom qiskit import QuantumCircuit\n\ndef c_amod15(a, x):\n    if a not in [2,7,8,11,13]:\n        raise ValueError(\"'a' must be 2,7,8,11,13\")\n    U = QuantumCircuit(4)        \n    for iteration in range(x):\n        if a in [2,13]:\n            U.swap(0,1)\n            U.swap(1,2)\n            U.swap(2,3)\n        if a in [7,8]:\n            U.swap(2,3)\n            U.swap(1,2)\n            U.swap(0,1)\n        if a == 11:\n            U.swap(1,3)\n            U.swap(0,2)\n        if a in [7,11,13]:\n            for q in range(4):\n                U.x(q)\n    U = U.to_gate()\n    U.name = \"%i^%i mod 15\" % (a, x)\n    c_U = U.control()\n    return c_U\n\ndef modular_exponentiation(circuit, n, m, a):\n    for x in range(n):\n        exponent = 2**x\n        circuit.append(c_amod15(a, exponent), [x] + list(range(n, n+m)))\n\nfrom qiskit.circuit.library import QFT\n\ndef inverse_qft(circuit, measurement_qubits):\n    circuit.append(QFT( len(measurement_qubits), do_swaps=False).inverse(), measurement_qubits)\n\ndef shors_algorithm(n, m, a):\n    qc = QuantumCircuit(n+m, n)\n    initialize_qubits(qc, n, m)\n    qc.barrier()\n    modular_exponentiation(qc, n, m, a)\n    qc.barrier()\n    inverse_qft(qc, range(n))\n    qc.measure(range(n), range(n))\n    return qc\n    \nn = 4; m = 4; a = 7\nfinal_circuit = shors_algorithm(n, m, a)\nfinal_circuit.draw('mpl')\n\n\n\n\n\nsimulator = Aer.get_backend('qasm_simulator')\ncounts = execute(final_circuit, backend=simulator, shots=1000).result().get_counts(final_circuit)\n\n\nfor measured_value in counts:\n    print(f\"{int(measured_value[::-1], 2)}\")\n\n9\n6\n5\n10\n15\n11\n8\n12\n14\n7\n0\n4\n13\n\n\n\nfrom math import gcd\nfor i in counts:\n    measured_value = int(i[::-1], 2)\n    if measured_value % 2 != 0:\n        print(\"Measured value not even\")\n        continue #measured value should be even as we are doing a^(r/2) mod N and r/2 should be int\n    x = int((a ** (measured_value/2)) % 15)\n    if (x + 1) % 15 == 0:\n        continue\n    factors = gcd(x + 1, 15), gcd(x - 1, 15) #we saw earlier that a^(r/2)+1 or a^(r/2)-1 should be a factor of 15\n    print(factors)\n\nMeasured value not even\n(1, 3)\nMeasured value not even\n(1, 3)\nMeasured value not even\nMeasured value not even\n(1, 15)\n(5, 3)\n(1, 3)\nMeasured value not even\n(1, 15)\n(5, 3)\nMeasured value not even"
  },
  {
    "objectID": "cwiczenia/cw1.html",
    "href": "cwiczenia/cw1.html",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "",
    "text": "python3 -m venv venv\nsource venv/bin/activate\n# Scripts\\Activate\n\npip install qiskit==0.44.1\npip install qiskit[visualization]\n# pip install 'qiskit[visualization]'\npip install qiskit_aer==0.12.2\npip install qiskit_machine_learning==0.6.1\npip install qiskit-finance==0.3.4\npip install qiskit-ibmq-provider==0.20.2\npip install qiskit-ignis==0.7.1\nfrom qiskit import  __qiskit_version__\nprint(__qiskit_version__)\n\nimport qiskit.tools.jupyter\n\n%qiskit_version_table"
  },
  {
    "objectID": "cwiczenia/cw1.html#qiskit-podstawy",
    "href": "cwiczenia/cw1.html#qiskit-podstawy",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Qiskit podstawy",
    "text": "Qiskit podstawy\nTworzenie rejestrów: kwantowego i klasycznego\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n\n\nqreq = QuantumRegister(4)\n\n\ncreg = ClassicalRegister(4)\n\n\ncircuit = QuantumCircuit(qreq, creg)\n\n\ncircuit.draw('mpl')\n\n\n\n\n\noutput = QuantumRegister(1)\n\n\ncircuit2 = QuantumCircuit(qreq, output, creg)\n\n\ncircuit2.draw(\"mpl\")\n\n\n\n\n\ncircuit3 = QuantumCircuit(qreq)\n\n\ncircuit3.draw('mpl')\n\n\n\n\n\ncircuit4 = QuantumCircuit(3,3)\ncircuit4.draw(\"mpl\")"
  },
  {
    "objectID": "cwiczenia/cw1.html#tworzenie-stanu-jednokubitowego",
    "href": "cwiczenia/cw1.html#tworzenie-stanu-jednokubitowego",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Tworzenie stanu jednokubitowego",
    "text": "Tworzenie stanu jednokubitowego\n\\[\n\\ket{\\psi}=\\ket{0}\n\\]\n\nfrom qiskit import QuantumRegister, QuantumCircuit, Aer, execute\n\n\nqr = QuantumRegister(1)\nqc = QuantumCircuit(qr)\n\n# klasyczny symulator pozwala zobaczyc stan\nbackend = Aer.get_backend('statevector_simulator')\njob=execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\nprint(state)\n\nStatevector([1.+0.j, 0.+0.j],\n            dims=(2,))\n\n\n\nstate.draw('latex')\n\n\\[ |0\\rangle\\]\n\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())\n\n\n\n\n\nqr = QuantumRegister(1)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\nstate.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |0\\rangle+\\frac{\\sqrt{2}}{2} |1\\rangle\\]\n\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())"
  },
  {
    "objectID": "cwiczenia/cw1.html#tworzenie-stanu-dwukubitowego",
    "href": "cwiczenia/cw1.html#tworzenie-stanu-dwukubitowego",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Tworzenie stanu dwukubitowego",
    "text": "Tworzenie stanu dwukubitowego\n\\[\n\\ket{00}, \\ket{01}, \\ket{10}, \\ket{11}\n\\]\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\nstate.draw('latex')\n\n\\[ |00\\rangle\\]\n\n\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.h(qr[1])\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\nstate.draw('latex')\n\n\\[\\frac{1}{2} |00\\rangle+\\frac{1}{2} |01\\rangle+\\frac{1}{2} |10\\rangle+\\frac{1}{2} |11\\rangle\\]\n\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())\n\n\n\n\n\nqr = QuantumRegister(2)\nqc = QuantumCircuit(qr)\nqc.h(qr[0])\nqc.cx(0,1)\n\nbackend = Aer.get_backend('statevector_simulator')\njob = execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\n\n\nqc.draw('mpl')\n\n\n\n\n\nstate.draw('latex')\n\n\\[\\frac{\\sqrt{2}}{2} |00\\rangle+\\frac{\\sqrt{2}}{2} |11\\rangle\\]\n\n\n\nfrom qiskit.visualization import plot_bloch_multivector\nplot_bloch_multivector(result.get_statevector())"
  },
  {
    "objectID": "cwiczenia/cw1.html#tworzenie-stanu-trzy-kubitowego",
    "href": "cwiczenia/cw1.html#tworzenie-stanu-trzy-kubitowego",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Tworzenie stanu trzy-kubitowego",
    "text": "Tworzenie stanu trzy-kubitowego\n\\[\n\\ket{000}, \\ket{001}, \\ket{010}, \\ket{011}, \\ket{100}, \\ket{101}, \\ket{110}, \\ket{111}\\]\n\nqr = QuantumRegister(3)\nqc = QuantumCircuit(qr)\n# qc.x(qr[0]) \n# qc.x(qr[1])\n\n# klasyczny symulator pozwala zobaczyc stan\nbackend = Aer.get_backend('statevector_simulator')\njob=execute(qc, backend)\nresult = job.result()\nstate = result.get_statevector()\n\nUruchom powyższy kod usuwajac poszczegolne komentarze i sprawdz wynik."
  },
  {
    "objectID": "cwiczenia/cw1.html#dostępne-symulatory",
    "href": "cwiczenia/cw1.html#dostępne-symulatory",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Dostępne symulatory",
    "text": "Dostępne symulatory\n\nAer.backends()\n\n[AerSimulator('aer_simulator'),\n AerSimulator('aer_simulator_statevector'),\n AerSimulator('aer_simulator_density_matrix'),\n AerSimulator('aer_simulator_stabilizer'),\n AerSimulator('aer_simulator_matrix_product_state'),\n AerSimulator('aer_simulator_extended_stabilizer'),\n AerSimulator('aer_simulator_unitary'),\n AerSimulator('aer_simulator_superop'),\n QasmSimulator('qasm_simulator'),\n StatevectorSimulator('statevector_simulator'),\n UnitarySimulator('unitary_simulator'),\n PulseSimulator('pulse_simulator')]\n\n\n\n# uruchom w środowisku IBM Quantum Experience\nfrom qiskit_ibm_provider import IBMProvider\n\nIBMProvider.save_account(token=MY_API_TOKEN)\nprovider = IBMProvider()\n\n# Create a circuit\nqc = QuantumCircuit(2)\nqc.h(0)\nqc.cx(0, 1)\nqc.measure_all()\n\n# Select a backend.\nbackend = provider.get_backend(\"ibmq_qasm_simulator\")\n\n# Transpile the circuit\ntranspiled = transpile(qc, backend=backend)\n\n# Submit a job.\njob = backend.run(transpiled)\n# Get results.\nprint(job.result().get_counts())\n\nWięcej informacji znajdziesz tutaj"
  },
  {
    "objectID": "cwiczenia/cw1.html#pomiar-w-obwodzie-i-wielokrotne-uruchamianie-układu",
    "href": "cwiczenia/cw1.html#pomiar-w-obwodzie-i-wielokrotne-uruchamianie-układu",
    "title": "Biblioteka Qiskit wprowadzenie",
    "section": "Pomiar w obwodzie i wielokrotne uruchamianie układu",
    "text": "Pomiar w obwodzie i wielokrotne uruchamianie układu\n\nfrom qiskit import QuantumRegister, ClassicalRegister, QuantumCircuit\n\nqreg = QuantumRegister(2)\ncreg = ClassicalRegister(2)\n\ncircuit = QuantumCircuit(qreg, creg)\ncircuit.h(qreg[0])\ncircuit.measure(qreg, creg)\n\n&lt;qiskit.circuit.instructionset.InstructionSet at 0x16a521a50&gt;\n\n\n\nfrom qiskit import execute, Aer\nfrom qiskit.visualization import plot_histogram\n\nsimulator = Aer.get_backend('qasm_simulator')\n\njob = execute(circuit, simulator, shots=1000)\nprint(job.job_id())\ncounts = job.result().get_counts(circuit)\nprint(counts)\ndisplay(plot_histogram(counts))\n\ncd5b0097-672b-4ba4-a7d4-68b3a9efcda5\n{'00': 515, '01': 485}"
  },
  {
    "objectID": "lectures/wyklad3.html",
    "href": "lectures/wyklad3.html",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "",
    "text": "\\[\n\\newcommand{\\bra}[1]{\\left \\langle #1 \\right \\rvert}\n\\newcommand{\\ket}[1]{\\left \\rvert #1 \\right \\rangle}\n\\newcommand{\\braket}[2]{\\left \\langle #1 \\middle \\rvert #2 \\right \\rangle}\n\\]\nMechanika Kwantowa opiera się na algebrze liniowej. W ogólności teoria ta posługuje się pojęciem nieskończenie wymiarowej przestrzeni liniowej. Na szczęście do opisu kubitów (2-dim) i układów kwantowych (\\(2^{n}\\)-dim) wystarczy nam pojęcie skończenie wymiarowej przestrzeni wektorowej. Bardzo upraszcza nam to naukę o kwantowym uczeniu maszynowym, gdyż wiele problemów matematycznych (dla fizyków) tutaj nie występuje. Upraszcza to również ilość potrzebnych matematycznych pojęć.\nBędziemy posługiwali się notacją Diraca, jednego z twórców mechaniki kwantowej. W książce Ch. Bernhardta “Obliczenia kwantowe dla każdego” autor rezygnuje z liczb zespolonych, na rzecz liczb rzeczywistych. O ile podejście takie sprawdza się na poziomie opisu o tyle dla pełnego zrozumienia posługiwanie się liczbami zespolonymi jest niezbędne."
  },
  {
    "objectID": "lectures/wyklad3.html#liczby-rzeczywiste-i-zespolone---przypomnienie",
    "href": "lectures/wyklad3.html#liczby-rzeczywiste-i-zespolone---przypomnienie",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Liczby rzeczywiste i zespolone - przypomnienie",
    "text": "Liczby rzeczywiste i zespolone - przypomnienie\nLiczby to matematyczne, abstrakcyjne pojęcia wywodzące się z teorii mnogości (zbiorów). Przykładowo, liczbę 42 można zapisa w postaci dziesiętnej lub binarnej \\(42=101010_2\\). Możemy znaleźć 42 przedmioty i je przeliczyć, ale w naszym przypadku skupimy się na abstrakcyjnym pojęciu liczby, niezależnie od jej reprezentacji. Liczba 42 jest liczbą naturalną. Zbiór liczb naturalnych oznaczamy jako \\(\\mathbb{N}\\). Identyczne cechy abstrakcji mają liczby całkowite \\(\\mathbb{Z}\\), liczby wymierne \\(\\mathbb{Q}\\), liczby rzeczywiste \\(\\mathbb{R}\\) oraz liczby zespolone \\(\\mathbb{C}\\). Nie możemy zobaczyć ani dotknąć liczb, ale możemy wykonywać na nich operacje matematyczne. Liczb Warto zaznaczyc,że liczby zespolone nie są bardziej abstrakcyjne niż liczby rzeczywiste, czy naturalne.\nLiczba zespolona (we współrzędnych Kartezjańskich) składa się z (dwóch liczb rzeczywistych) części rzeczywistej i urojonej: \\[z=x + i y\\] gdzie \\(i^2=-1\\).\nNatomiast częśc rzeczywista \\(R(z)=x\\) i częśc urojona \\(I(z)=y\\).\nNa przykład: \\[1+i\\sqrt{3}\\] \\(R(z)=1\\) i \\(I(z)=\\sqrt{3}\\).\nInaczej mówiąc, liczba zespolona jest sumą liczby rzeczywistej i urojonej.\nLiczy zespolone, można traktowac jako punkty na płaszczyźnie o współrzędnych \\(x\\) i \\(y\\).\n\nKażdą liczbę zespoloną możemy zapisać w postaci polarnej (współrzędne biegunowe) \\[ z=r\\, e^{i \\phi} , \\] gdzie \\(r=|z|\\) to moduł liczby zespolonej, a \\(\\phi\\) to jej argument czyli wyrażony w radianach kąt między osią rzeczywistą a półprostą poprowadzoną od środka ukł. wsp. i przechodzącą przez punkt \\(z\\). \\[ z = r\\, e^{i \\, \\phi} = r\\, (\\cos{\\phi} + i\\, \\sin{\\phi})\\] gdzie: \\[r = |z| = \\sqrt{x^2 + y^2}\\] \\[\\phi = \\arctan{\\frac{y}{x}}. \\] Natomiast: \\[x = r \\cos{\\phi}\\] \\[y = r \\sin{\\phi}\\]\nDla naszego przykładu: \\[1+i\\sqrt{3} = 2 e^{i \\frac{\\pi}{3}} . \\]\n\nUdowodnij samodzielnie, że powyższe równanie jest prawdziwe.\n\nLiczby zespolone można dodawa, mnożyc i dzieli zgodnie z zwykłymi regułami arytmetyki. Dodawanie liczb zespolonych jest łatwe dla liczb w postaci kartezjańskiej. Natomiast mnożenie liczb zespolonych upraszcza się dla postaci biegunowej (następuje zamiana mnożenia na dodawanie fazy).\nLiczba sprzężona do liczby zespolonej powstaje poprzez zmianę znaku części urojonej\n\\(z=x + i\\, y\\,\\,\\,\\,\\) to \\(\\,\\,\\,z^*=x - i y = r*e^{-i \\phi}\\).\nNorma liczby zespolonej \\(z=x + i y\\,\\,\\,\\,\\) to \\(\\,\\,\\,|z|=\\sqrt{x^2 + y^2}=r\\).\nKwadrat normy liczby zespolonej \\(z=x + i y\\,\\,\\,\\,\\) to \\(\\,\\,\\, |z|^2=x^2 + y^2=r^2\\). Warto zauważyc, że każdy kwadrat modułu daje w wyniku nieujemną liczbę rzeczywistą.\nMożna go również zapisać jako \\[|z|^2=z z^* = z^* z\\]\nCzynniki fazowe to szczególna klasa liczb zespolonych \\(z\\) dla której \\(r=1\\).\nOtrzymujemy wtedy: \\[\nz=e^{i \\phi}=\\cos{\\phi} + i\\, \\sin{\\phi}\\] \\[\nz z^* = 1\n\\]\n\nUdowodnij w kartezjańskim i polarnym układzie oniesienia.\n\n\nile wynosi \\(z_1 z_2\\)\n\n\nile wynosi \\(\\frac{z_1}{z_2}\\)"
  },
  {
    "objectID": "lectures/wyklad3.html#wektory-i-przestrzenie-wektorowe",
    "href": "lectures/wyklad3.html#wektory-i-przestrzenie-wektorowe",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Wektory i przestrzenie wektorowe",
    "text": "Wektory i przestrzenie wektorowe\nNiech dany będzie zbiór \\(\\mathbb{V}\\) oraz zbiór \\(\\mathbb{K}\\). Elementy zbioru \\(\\mathbb{V}\\) można ze sobą dodawać i mnożyć przez elementy zbioru \\(\\mathbb{K}\\). Wraz z dodatkowymi opracjami (zdefiniowanymi poniżej) zbiór ten będziemy nazwywali przestrzenią wektorową. Jej elementy to wektory ket \\(\\ket{u}\\) (lub kety).\nJeśli współczynniki liczbowe wektorów będą rzeczywiste to będziemy mówić o przestrzeni wektorowej rzeczywistej. Natomiast jeśli liczby te będą zespolone to będziemy mówić o przestrzeni wektorowej zespolonej.\nMyśląc o wektorach często wyobrażamy je sobie jako strzałki w przestrzeni. Przez strzałki rozumiemy tutaj obiekty znajdujące się w zwykłej przestrzeni i posiadające wielkoś oraz kierunek. Wektory takie mają trzy składowe - trzy (rzeczywiste) współrzędne przestrzenne.\nNa tych zajęciach lepiej zapomniec o tej koncepcji. Wszystkie wektory będą reprezentowane jako abstrakcyjne elementy przestrzeni wektorowej. Warto jednak pamiętać, że wszystkie własności (algebraiczne) wektorów są również spełnione dla strzałek.\n\nAksjomaty przestrzeni stanów\nNiech \\(\\ket{v}\\) , \\(\\ket{u}\\), \\(\\ket{z}\\) będą dowolnymi wektorami, natomiast \\(\\alpha\\) i \\(\\beta\\) dowolnymi liczbami.\n\nSuma dwóch wektorów ket jest wektorem ket \\[\\ket{v} + \\ket{u} = \\ket{z}\\]\nDodawanie wektorów jest przemienne: \\[\\ket{v} + \\ket{u} = \\ket{u} + \\ket{v}\\]\nDodawanie wektorów jest łączne: \\[\\ket{v} + (\\ket{u} + \\ket{z}) = (\\ket{v} + \\ket{u}) + \\ket{z}\\]\nIstnieje szczególny (i jedyny) wektor \\(\\ket{v}\\) odwrotny do wektora \\(\\ket{u}\\): \\[\\ket{v} + \\ket{u} = 0\\]\nIstnieje szczególny (i jedyny) wektor \\(0\\) zerowy. Dla każdego wektora \\(\\ket{v}\\) zachodzi: \\[\\ket{v} + 0 = 0 + \\ket{v} = \\ket{v}\\]\n1*wektor = wektor: \\[1 \\ket{v} = \\ket{v}\\]\nŁączność mnożenia przez skalar: \\[\\alpha (\\beta \\ket{v}) = (\\alpha \\beta) \\ket{v}\\]\nRozdzielność mnożenia przez skalar względem dodawania wektorów: \\[\\alpha (\\ket{v} + \\ket{u}) = \\alpha \\ket{v} + \\alpha \\ket{u}\\]\nRozdzielność dodawania skalarów względem mnożenia przez wektor: \\[(\\alpha + \\beta) \\ket{v} = \\alpha \\ket{v} + \\beta \\ket{v}\\]\n\n\n\nWektory kolumnowe\nZapiszmy pionową jednokolumnową tablicę liczb: \\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix} \\]\nMnożenie przez liczbę: \\[ \\alpha \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix} = \\begin{bmatrix} \\alpha x_1 \\\\ \\alpha x_2 \\\\ .\\\\ \\alpha x_n \\end{bmatrix} \\]\nDodawanie kolumn: \\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix} + \\begin{bmatrix} y_1 \\\\ y_2 \\\\ .\\\\ y_n \\end{bmatrix} = \\begin{bmatrix} x_1+y_1 \\\\ x_2+y_2 \\\\ .\\\\ x_n+y_n \\end{bmatrix}\\]\nPozwala to otrzymać konkretną reprezentację wektorów, które będziemy oznaczać w notacji Diraca przez “ket” \\(\\ket{.}\\).\n\n\nWektory wierszowe\n\\[ \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}\\]\nAnalogicznie do poprzedniego przykładu łatwo określić jak dodawać je ze sobą i mnożyć przez liczbę. W notacji Diraca będziemy takie wektory oznaczali przez “bra” \\(\\bra{.}\\).\n\n\nTranspozycja i sprzężenie Hermitowskie.\nTranspozycja \\(T\\) Zamienia wektory wierszowe na kolumnowe i odwrotnie.\n\\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}^{T} = \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}\\]\noraz \\[ \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}^{T} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}\\]\nNatomiast sprzężenie hermitowskie \\(\\dagger = T \\ast\\) dodatkowo do transpozycji dodaje sprzężenie zespolone.\n\\[\\ket{u}^{\\dagger} = \\bra{u}\\] \\[\\bra{u}^{\\dagger} = \\ket{u}\\]\nCzyli: \\[ (\\ket{u} + \\ket{v})^{\\dagger} = \\bra{u} + \\bra{v} \\] oraz \\[ \\alpha \\ket{u} \\to \\bra{u} \\alpha^*\\]\n\\[ \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}^{\\dagger} = \\begin{bmatrix} x_1^* \\,\\, x_2^* \\,\\, \\dots \\,\\, x_n^* \\end{bmatrix}\\]\noraz \\[ \\begin{bmatrix} x_1 \\,\\, x_2 \\,\\, \\dots \\,\\, x_n \\end{bmatrix}^{\\dagger} = \\begin{bmatrix} x_1^* \\\\ x_2^* \\\\ .\\\\ x_n^* \\end{bmatrix}\\]\n\n\nIloczyn skalarny\nIloczynem skalarnym dwóch wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) nazywany funkcję, która zwraca liczbę.\n\n\\(\\braket{u}{v} = \\braket{v}{u}^{\\ast}\\)\n\\((\\alpha \\bra{u})\\ket{v} = \\alpha \\braket{u}{v}\\)\n\\((\\bra{u} + \\bra{v}) \\ket{z} = \\braket{u}{z} +\\braket{v}{z}\\)\n\\(\\braket{u}{u} &gt; 0\\)\n\\(\\braket{u}{u} = 0, gdy \\ket{u}=\\ket{0}\\)\n\nDla dwóch wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) otrzymujemy: \\[ \\ket{u} = \\begin{bmatrix} x_1 \\\\ x_2 \\\\ .\\\\ x_n \\end{bmatrix}, \\ket{v} = \\begin{bmatrix} y_1 \\\\ y_2 \\\\ .\\\\ y_n \\end{bmatrix} \\]\n\\[ \\braket{u}{v} = x_1^{*}y_1 +x_2^{*}y_2 + \\dots + x_n^{*}y_n\\]\n\nZadanie - Udowodnij, że \\(\\braket{u}{u}\\) jest liczbą rzeczywistą.\n\nwektor znormalizowany \\(\\braket{u}{u}=1\\)\nwektory ortogonalne \\(\\braket{u}{v}=0\\)\n\n\nKombinacja liniowa wektorów\nDla dwóch wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) oraz dwóch liczb \\(\\alpha\\), \\(\\beta\\) możemy stworzyć nowy wektor: \\[\\ket{z} = \\alpha \\ket{u} + \\beta \\ket{v}\\] Wektor ten nazywamy kombinacją liniową wektorów \\(\\ket{u}\\) i \\(\\ket{v}\\) o współczynnikach \\(\\alpha\\) i \\(\\beta\\).\n\n\nBaza\nKażda przestrzeń wektorowa ma bazę.\nDowolny wektor można zapisa jako kombinację liniową wektorów bazowych.\nInteresowac będzie nas baza (obliczeniowa) dla której:\n\\[ \\braket{e_i}{e_i}=1 \\,\\, \\braket{e_i}{e_j}=0 \\,\\, \\text{dla i} \\neq j \\] gdzie \\(i,\\,j = 1,2,\\dots, n\\).\nDowolny wektor \\(\\ket{u}\\) możemy zapisa jako: \\[ \\ket{u} = \\braket{e_1}{u}\\ket{e_1} + \\braket{e_2}{u}\\ket{e_2} + ... + \\braket{e_n}{u}\\ket{e_n}  \\]\nWarto zauważyc: \\[\\braket{e_1}{u}= x_1\\] \\[\\ket{u} = \\sum_{i=1}^{n} \\ket{i}\\bra{i} \\ket{u}\\]"
  },
  {
    "objectID": "lectures/wyklad3.html#formalizm-matematyczny-obliczeń-kwantowych",
    "href": "lectures/wyklad3.html#formalizm-matematyczny-obliczeń-kwantowych",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Formalizm matematyczny obliczeń kwantowych",
    "text": "Formalizm matematyczny obliczeń kwantowych\nTa wiedza wystarczy do wyjaśnienia notacji Diraca.\nIloczyn skalarny \\(\\braket{\\psi}{\\phi}\\) wektorów \\(\\ket{\\psi}\\) i \\(\\ket{\\phi}\\) czytamy jako braket u v.\n\nStan\nW fizyce klasycznej znajomoś stan układu oznacza, iż wiemy wszystko co jest potrzebne\nStanem w mechanice kwantowej nazywamy wektor:\n\\[\\ket{\\psi} = x_0 \\ket{0} + x_1 \\ket{1} + \\dots x_{n-1} \\ket{n-1}\\]\nChcemy aby współczynniki \\(x_i\\) były liczbami zespolonymi a cały wektor był unormowany do 1.\nLiczby \\(x_i\\) nazywamy amplitudami prawdopodobieństwa stanu kwantowego. Jeśli przynajmniej dwie liczby \\(x_i\\) są niezerowe, to układ znajduje się w superpozycji stanów.\n\n\nKubit\nElementarnym obiektem w informatyce kwantowej jest kubit, który realizowany jest jako dwu wymiarowy układ kwantowy. Stan kwantowy kubitu opisuje wektor w przestrzeni liniowej \\(\\mathbb{C}^2\\).\nW celu wykonywania obliczeń i opisu stanu kubitu wybierzemy tzw. bazę obliczeniową: \\[\\ket{0} = \\begin{bmatrix} 1 \\\\ 0  \\end{bmatrix} , \\ket{1} = \\begin{bmatrix} 0 \\\\ 1  \\end{bmatrix}\\]\nTo co wyróżnia kubit w porównaniu do klasycznego bitu dowolny stan \\(\\ket{\\psi}\\) może być superpozycją stanów bazowych: \\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1} = \\alpha \\begin{bmatrix} 1 \\\\ 0\\end{bmatrix} + \\beta \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}\n\\] dla którego zachodzi warunek normalizacji: \\[\n\\braket{\\psi}{\\psi} = |\\alpha|^2 + |\\beta|^2 = 1\n\\] gdzie \\(\\alpha, \\beta \\in \\mathbb{C}\\).\n\nZADANIE - oblicz \\(\\braket{\\psi}{\\psi}\\).\n\nLiczby \\(\\alpha\\) i \\(\\beta\\) nazywamy amplitudami prawdopodobieństwa. Są one reprezentowane przez liczby zespolone. Potrzeba 4 liczb rzeczywistych aby je opisać. Ze względu na warunek normalizacji jedną liczbę można obliczyc co oznacza potrzebę użycia już tylko trzech liczb rzeczywiste.\nStan kubitu możemy zapisać w postaci: \\[\n\\ket{\\psi} = e^{i \\gamma}\\left( \\cos{\\frac{\\phi}{2}} \\ket{0} + e^{i \\theta} \\sin{\\frac{\\phi}{2}} \\ket{1} \\right)\n\\] gdzie \\(\\phi \\in [0, \\pi]\\), \\(\\theta \\in [0, 2\\pi]\\) i \\(\\gamma \\in [0, 2\\pi]\\) są liczbami rzeczywistymi.\nWspółczynnik \\(e^{i \\gamma}\\) nazywamy fazą globalną. Ze względu, iż analizować będziemy kwadraty amplitud prawdopodobieństwa to faza globalna nie ma znaczenia. Dlatego możemy napisać: \\[\n\\ket{\\psi} = \\cos{\\frac{\\phi}{2}} \\ket{0} + e^{i \\theta} \\sin{\\frac{\\phi}{2}} \\ket{1}\n= \\begin{bmatrix} \\cos{\\frac{\\phi}{2}} \\\\ e^{i \\theta} \\sin{\\frac{\\phi}{2}} \\end{bmatrix}\n\\]\nWarto zauważyć, że dwa dowolne stany kubitów \\(\\ket{\\psi}\\) i \\(\\ket{\\phi}\\) różnią się o czynnik fazowy \\(e^{i \\gamma}\\) to stany te dają identyczne wyniki.\nLiczby rzeczywiste \\(\\phi\\) i \\(\\theta\\) nazywamy kątami kubitu i możemy interpretować je jako współrzędne na sferze Blocha. Bardzo często będziemy wykorzystywać ją do wizualizacji stanów kubitów.\nStany w bazie obliczeniowej, którymi często będziemy operowac: \\[\\ket{+} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})\\] \\[\\ket{-} = \\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1})\\] \\[\\ket{i} =\\frac{1}{\\sqrt{2}}(\\ket{0} + i \\ket{1})\\] \\[\\ket{-i} =\\frac{1}{\\sqrt{2}}(\\ket{0} - i \\ket{1})\\]\nLub: \\[\\frac{1}{\\sqrt{2}}(\\ket{0} + e^{i\\pi/6} \\ket{1})\\] \\[\\frac{\\sqrt{3}}{2}(\\ket{0} + \\frac{1}{2} \\ket{1})\\]\n\nKubit może by dowolnym punktem na sferze Blocha.\n\n\n\nDwa kubity\nZłączenie układu dwóch kubitów realizowane jest przez iloczyn tensorowy (iloczyn Kroneckera).\nRozważmy dwa stany kubitów \\(\\ket{\\psi}\\), \\(\\ket{\\phi}\\)\n\\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1} = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}\\, ,\\,\\,\n\\ket{\\phi} = \\gamma \\ket{0} + \\delta \\ket{1} = \\begin{bmatrix} \\gamma \\\\ \\delta \\end{bmatrix}\n\\]\nStan dwukubitowy: \\[\n\\ket{\\psi} \\otimes \\ket{\\phi} = \\begin{bmatrix} \\alpha \\gamma \\\\ \\alpha \\delta \\\\ \\beta \\gamma \\\\ \\beta \\delta \\end{bmatrix} = \\alpha \\gamma \\ket{0} \\otimes \\ket{0} + \\beta \\delta \\ket{1} \\otimes \\ket{0}  + \\alpha \\delta \\ket{0} \\otimes \\ket{1}  + \\beta \\delta \\ket{1} \\otimes \\ket{1}\n\\] co możemy zapisa jako: \\[\n\\ket{\\psi \\phi} = \\alpha \\gamma \\ket{00} + \\beta \\delta \\ket{10}  + \\alpha \\delta \\ket{01}  + \\beta \\delta \\ket{11}\n\\] gdzie: \\[\n\\ket{00} = \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\, \\,\n\\ket{01} = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix}, \\, \\,\n\\ket{10} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 1 \\\\ 0 \\end{bmatrix}, \\, \\,\n\\ket{11} = \\begin{bmatrix} 0 \\\\ 0 \\\\ 0 \\\\ 1 \\end{bmatrix}\n\\]\nPo przenumerowaniu stanów możemy napisac: \\[\n\\ket{\\Phi} = c_0 \\ket{0} + c_1 \\ket{1}  + c_2 \\ket{2}  + c_3 \\ket{3}\n\\] dla którego: \\[\n|c_0|^2 + |c_1|^2 + |c_2|^2 + |c_3|^2 = 1\n\\]\n\n\nStan separowalny i splątany\nJeżeli istnieją stany \\(\\ket{\\phi_1}\\) i \\(\\ket{\\phi_2}\\) takie, że \\[\\ket{\\psi} = \\ket{\\phi_1} \\otimes \\ket{\\phi_2}\\] to stan nazywamy separowalny.\nZobaczmy, czy istnieje przypadek w którym stan układu dwóch kubitów nie da się zaprezentowac jako iloczynu tensorowego podukładów. Aby to sprawdzic zobaczmy czy istnieją takie liczby \\(c_0, c_1, c_2, c_3\\) dla których nie da się znaleźc \\(\\alpha, \\beta,\\gamma, \\delta\\), które spełniają układ równań: \\[c_0 = \\alpha \\gamma , \\, c_1 = \\alpha \\delta , \\, c_2 = \\beta \\gamma , \\, c_3 = \\beta \\delta \\]\nRozważmy stan \\[\\ket{bell} = \\frac{1}{\\sqrt{2}}(\\ket{0}+\\ket{3}) = \\frac{1}{\\sqrt{2}}(\\ket{00}+\\ket{11})\\]\nZałóżmy, że możemy zapisa stan bell w postaci: \\[ \\alpha \\gamma \\ket{0} + \\beta \\delta \\ket{1}  + \\alpha \\delta \\ket{2}  + \\beta \\delta \\ket{3} \\]\nAby stan bell był separowalny musi by spełniony układ równań:\n\\[\\begin{eqnarray}\n\\alpha \\gamma = \\frac{1}{\\sqrt{2}} \\\\ \\alpha \\delta = 0 \\\\ \\beta \\gamma = 0 \\\\ \\beta \\delta =\\frac{1}{\\sqrt{2}}\n\\end{eqnarray}\\]\nZ warunku drugiego mamy dwie możliwości: albo \\(\\alpha=0\\) lub \\(\\delta=0\\). Jeżeli \\(\\alpha=0\\) to warunek pierwszy nie może byc spełniony. Jeżeli \\(\\delta=0\\) to warunek czwarty nie może byc spełniony. Otrzymujemy sprzecznośc.\nProwadzi to do wniosu, że stan bell'a nie jest stanem separowalnym i jest stanem splątanym. Stany te mają bardzo nieintuicyjne własności. Związany jest z nimi słynny paradox EPR oraz tak zwane nierówności Bella.\n\nSplątane stany Bell’a, wraz z zasadą superpozycji będą podstawowymi kwantowymi własnościami pozwalającymi zrealizowac przewagę obliczeń kwantowych nad obliczeniami klasycznymi."
  },
  {
    "objectID": "lectures/wyklad3.html#pomiar-w-bazie-z",
    "href": "lectures/wyklad3.html#pomiar-w-bazie-z",
    "title": "Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów",
    "section": "Pomiar w bazie Z",
    "text": "Pomiar w bazie Z\nW opisie kubitów wybraliśmy specyficzą bazę (obliczeniową) wektorów, która rozkłada każdy wektor na kombinację wektora \\(\\ket{0}\\) i \\(\\ket{1}\\).\nZasady przestrzeni wektorowej i mechaniki kwantowej dopuszczają tworzenie kombinacji liniowej (superpozycji) dla tych dwóch stanów. \\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1}\n\\] Po pomiarze kubitu, czyli na końcu procesu obliczeniowego, ze względu na prawa fizyki otrzymujemy tylko i wyłącznie jeden ze stanów bazowych \\(\\ket{0}\\) lub \\(\\ket{1}\\). Każdy następny pomiar (tej samej obserwabli) będzie kończyc się w tym samym (otrzymanym) stanie.\n\nPomiar niszczy superpozycję kubitu i sprowadza go do jednego ze stanów bazowych.\n\nDla kubitu w superpozycji stanów bazowych jedyne co możemy określic to prawdopodobieństwo otrzymania stanu \\(\\ket{0}\\) i \\(\\ket{1}\\).\n\nPrawdopodobieństwo określone jest jako kwadrat (modułu) amplitudy Dla stanu \\(\\ket{0}\\) \\(P(0) = |\\alpha|^2\\) oraz dla stanu \\(\\ket{1}\\) \\(P(1)= |\\beta|^2\\).\n\nIstnieje możliwośc pomiaru kubitów w innych bazach. Jednak w większości przypadków ograniczymy się do pomiaru w bazie obliczeniowej.\n\nPrzykład\nRozważmy stan \\[\\ket{\\psi} = \\frac{\\sqrt{3}}{2}\\ket{0}+\\frac{1}{2}\\ket{1}\\]\nMożliwe wyniki pomiaru w bazie Z \\(\\{ \\ket{0},\\ket{1} \\}\\).\n\\[\n\\braket{0}{\\psi} = \\bra{0}\\left( \\frac{\\sqrt{3}}{2}\\ket{0} +\\frac{1}{2}\\ket{1}\\right) = \\frac{\\sqrt{3}}{2}\\braket{0}{0} + \\frac{1}{2}\\braket{0}{1} = \\frac{\\sqrt{3}}{2}\n\\] Biorąc kwadrat apmlitudy otrzymujemy kubit w stanie \\(\\ket{0}\\) z prawdopodobieństwem \\(0.75\\). \\[\n\\braket{1}{\\psi} = \\bra{1}\\left( \\frac{\\sqrt{3}}{2}\\ket{0} +\\frac{1}{2}\\ket{1}\\right) = \\frac{\\sqrt{3}}{2}\\braket{1}{0} + \\frac{1}{2}\\braket{1}{1} = \\frac{1}{2}\n\\] Biorąc kwadrat apmlitudy otrzymujemy stan \\(\\ket{1}\\) z prawdopodobieństwem \\(0.25\\).\n\\[\\ket{\\psi} = \\braket{0}{\\psi}\\ket{0} + \\braket{1}{\\psi}\\ket{1}\\]\nDowolna para liniowo niezależnych wektorów jednostkowych \\(\\ket{u}\\) i \\(\\ket{v}\\) pochodząca z dwuwymiarowej przestrzeni wektorowej może tworzyc bazę: \\[\n\\alpha \\ket{0} +\\beta \\ket{1} = \\alpha' \\ket{u} +\\beta' \\ket{v}\n\\] Przykładem może byc tzw Baza Hadamarda \\(\\ket{+}\\) i \\(\\ket{-}\\) zdefiniowana jako: \\[\n\\ket{+} = \\frac{1}{\\sqrt{2}}(\\ket{0}+\\ket{1}) = \\begin{bmatrix} \\frac{1}{\\sqrt{2}} \\\\ \\frac{1}{\\sqrt{2}} \\end{bmatrix}\n\\] \\[\n\\ket{-} = \\frac{1}{\\sqrt{2}}(\\ket{0}-\\ket{1}) = \\begin{bmatrix} \\frac{1}{\\sqrt{2}} \\\\ - \\frac{1}{\\sqrt{2}} \\end{bmatrix}\n\\]\n\nBardzo ważnym etapem jest wybór bazy w której dokonujemy pomiaru. np. dla wektora \\(\\ket{+}\\) pomiar w bazie standardowej pozwoli otrzymac wyniki stanu \\(\\ket{0}\\) i \\(\\ket{1}\\) z prawdopodobieństwami \\(\\frac{1}{2}\\). Natomiast jeśli pomiar dokonywany byłby w bazie Hadamarda to zawsze otrzymamy stan \\(\\ket{+}\\) z prawdopodobieństwem 1."
  },
  {
    "objectID": "lectures/wyklad4.html",
    "href": "lectures/wyklad4.html",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "",
    "text": "Zmianę stanu kwantowego w czasie opisuje Ewolucja kwantowa.\nRozważmy stan układu w chwili \\(t=0\\).\n\\[\\ket{\\psi_{t=0}}\\] W chwili \\(t=1\\) otrzymujemy stan \\(\\ket{\\psi_{t=1}}\\) t. że: \\[\\ket{\\psi_{t=1}} = \\textbf{U} \\, \\ket{\\psi_{t=0}} \\] gdzie \\(\\textbf{U}\\) jest macierzą unitarną.\nPowyższe równanie opisuje zachowanie wszystkich układów kwantowych.\nRozważmy stany bazowe \\(\\ket{0}\\), \\(\\ket{1}\\), które będziemy chcieli zamienic w ich superpozycję. \\[\n\\textbf{U}\\ket{0} = a\\ket{0} + b\\ket{1} = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\n\\] \\[\n\\textbf{U}\\ket{1} = c\\ket{0} + d\\ket{1} = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\n\\]\nKorzystając z tych równań możemy napisac: \\[\n\\textbf{U} = \\left( \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\right) = \\begin{bmatrix} a \\, \\, b \\\\ c \\,\\, d \\end{bmatrix}\n\\]\nW informatyce macierze unitarne będą realizowały logiczne bramki kwantowe.\n\nDlaczego bramki kwantowe muszą by unitarne?\n\nNorma stanu kwantowego wynosi zawsze 1. Jest to prawdopodobieństwo całkowite sumy stanów bazowych. Prawdopodobieństwo to powinno by zachowane. Co oznacza, że chcemy znaleźc taką transformację, która nie zmienia długości (kwadratu) wektora. Taka transformacja realizowana jest przez obroty.\nWarto zwrócic uwagę na jeszcze jeden fakt. Macierz odwrotna do \\(\\textbf{U}\\) (oznaczana jako \\(\\textbf{U}^{-1}\\)) zawsze istnieje i jest ona równa sprzężeniu Hermitowskiemu macierzu \\(\\textbf{U}=\\textbf{U}^{\\dagger}\\). Dlatego ewolucja stanów kwantowych zawsze jest odwracalna. A to oznacza, że i bramki muszą by operacjami odwracalnymi. \\[\\ket{\\psi_{t=0}} = \\textbf{U}^{\\dagger} \\ket{\\psi_{t=1}} \\]"
  },
  {
    "objectID": "lectures/wyklad4.html#ewolucja-kwantowa",
    "href": "lectures/wyklad4.html#ewolucja-kwantowa",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "",
    "text": "Zmianę stanu kwantowego w czasie opisuje Ewolucja kwantowa.\nRozważmy stan układu w chwili \\(t=0\\).\n\\[\\ket{\\psi_{t=0}}\\] W chwili \\(t=1\\) otrzymujemy stan \\(\\ket{\\psi_{t=1}}\\) t. że: \\[\\ket{\\psi_{t=1}} = \\textbf{U} \\, \\ket{\\psi_{t=0}} \\] gdzie \\(\\textbf{U}\\) jest macierzą unitarną.\nPowyższe równanie opisuje zachowanie wszystkich układów kwantowych.\nRozważmy stany bazowe \\(\\ket{0}\\), \\(\\ket{1}\\), które będziemy chcieli zamienic w ich superpozycję. \\[\n\\textbf{U}\\ket{0} = a\\ket{0} + b\\ket{1} = \\begin{bmatrix} a \\\\ b \\end{bmatrix}\n\\] \\[\n\\textbf{U}\\ket{1} = c\\ket{0} + d\\ket{1} = \\begin{bmatrix} c \\\\ d \\end{bmatrix}\n\\]\nKorzystając z tych równań możemy napisac: \\[\n\\textbf{U} = \\left( \\begin{bmatrix} a \\\\ b \\end{bmatrix} \\begin{bmatrix} c \\\\ d \\end{bmatrix}\\right) = \\begin{bmatrix} a \\, \\, b \\\\ c \\,\\, d \\end{bmatrix}\n\\]\nW informatyce macierze unitarne będą realizowały logiczne bramki kwantowe.\n\nDlaczego bramki kwantowe muszą by unitarne?\n\nNorma stanu kwantowego wynosi zawsze 1. Jest to prawdopodobieństwo całkowite sumy stanów bazowych. Prawdopodobieństwo to powinno by zachowane. Co oznacza, że chcemy znaleźc taką transformację, która nie zmienia długości (kwadratu) wektora. Taka transformacja realizowana jest przez obroty.\nWarto zwrócic uwagę na jeszcze jeden fakt. Macierz odwrotna do \\(\\textbf{U}\\) (oznaczana jako \\(\\textbf{U}^{-1}\\)) zawsze istnieje i jest ona równa sprzężeniu Hermitowskiemu macierzu \\(\\textbf{U}=\\textbf{U}^{\\dagger}\\). Dlatego ewolucja stanów kwantowych zawsze jest odwracalna. A to oznacza, że i bramki muszą by operacjami odwracalnymi. \\[\\ket{\\psi_{t=0}} = \\textbf{U}^{\\dagger} \\ket{\\psi_{t=1}} \\]"
  },
  {
    "objectID": "lectures/wyklad4.html#bramki-jednokubitowe",
    "href": "lectures/wyklad4.html#bramki-jednokubitowe",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "Bramki jednokubitowe",
    "text": "Bramki jednokubitowe\nSpośród wszystkich bramek kwantowych istnieje kilka, które mają swoje ustalone nazwy. Są one często wykorzystywane w obliczeniach kwatnowych. Rozważmy stan \\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1}\n\\]\n\nBramka identycznościowa\n\\[\n\\textbf{I} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix}\n\\]\nZobaczmy jak operator ten działa na stany bazowe: \\[ \\textbf{I} \\ket{0} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\]\n\\[ \\textbf{I} \\ket{1} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{I} \\ket{\\psi} = \\begin{bmatrix} 1 \\,\\, 0 \\\\ 0 \\,\\, 1 \\end{bmatrix} \\ket{\\psi} =  \\textbf{I} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha \\ket{0} + \\beta \\ket{1}\n\\]\n\n\nBramka negacji X (NOT)\n\\[\n\\textbf{X} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1 \\,\\, 0 \\end{bmatrix}\n\\]\n\\[\n\\textbf{X} \\ket{0} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1\\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\ket{1}\n\\]\n\\[\n\\textbf{X} \\ket{1} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1 \\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\ket{0}\n\\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{X} \\ket{\\psi} = \\begin{bmatrix} 0 \\,\\, 1 \\\\ 1 \\,\\, 0 \\end{bmatrix} \\ket{\\psi} =  \\textbf{X} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha \\ket{1} + \\beta \\ket{0}\n\\]\n\n\nBramka negacji fazy Y\n\\[\n\\textbf{Y} = \\begin{bmatrix} 0 \\,\\, -i \\\\ i \\,\\,\\,\\,\\,\\,\\, 0 \\end{bmatrix}\n\\]\n\\[\n\\textbf{Y} \\ket{0} = \\begin{bmatrix} 0 \\,\\, -i \\\\ i \\,\\,\\,\\,\\,\\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = i \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = i \\ket{1}\n\\]\n\\[\n\\textbf{Y} \\ket{1} = \\begin{bmatrix} 0 \\, -i \\\\ i \\,\\,\\,\\,\\,\\, 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = -i \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = -i \\ket{0}\n\\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{Y} \\ket{\\psi} = \\begin{bmatrix} 0 \\,\\, -i \\\\ i \\,\\,\\,\\,\\,\\, 0 \\end{bmatrix} \\ket{\\psi} =  \\textbf{Y} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha i \\ket{1} - \\beta i \\ket{0}\n\\]\n\n\nBramka negacji fazy i bitu Z\n\\[\n\\textbf{Z} = \\begin{bmatrix} 1 \\,\\,\\,\\,\\,\\,\\,\\,\\, 0 \\\\ 0\\,\\, -1 \\end{bmatrix}\n\\]\n\\[ \\textbf{Z} \\ket{0} = \\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 0 \\\\ 0 \\, -1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = 1 \\ket{0} \\]\n\\[ \\textbf{Z} \\ket{1} = \\begin{bmatrix} 1 \\,\\,\\,\\,\\,\\,\\, 0 \\\\ 0 \\, -1 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = -1 \\ket{1}\\]\nDziałając na stan \\(\\ket{\\psi}\\) otrzymujemy: \\[\n\\textbf{Z} \\ket{\\psi} = \\begin{bmatrix} 0 \\,\\,\\,\\,\\,\\,\\, 1 \\\\ 0 \\, -1 \\end{bmatrix} \\ket{\\psi} =  \\textbf{Z} \\left( \\alpha \\ket{0} + \\beta \\ket{1} \\right) = \\alpha \\ket{0} - \\beta \\ket{1}\n\\]\n\n\nBramka Hadamarda H\n\\[\n\\textbf{H}= \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 1 \\\\ 1 \\, -1 \\end{bmatrix}\n\\]\n\\[\n\\textbf{H} \\ket{0} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 1 \\\\ 1 \\, -1 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\frac{1}{\\sqrt{2}} \\left( \\ket{0} + \\ket{1} \\right) = \\ket{+}\n\\]\n\\[\n\\textbf{H} \\ket{1} = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1\\,\\,\\,\\,\\,\\,\\, 1 \\\\ 1 \\, -1 \\end{bmatrix}  \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} = \\frac{1}{\\sqrt{2}} \\left( \\ket{0} - \\ket{1} \\right) = \\ket{-}\n\\]\n\n\n\nLosowy bit\nStwórzmy pierwszy kwantowy program, który wykona zadanie niemożliwe do zrealizowania na komputerze klasycznym. Jak można zauważyc zdefiniowaliśmy bramkę Hadamarda. Brami tej nie było w klasycznych bramkach realizujących operacje na bitach.\nNa przestrzeni dziejów informatyki bardzo dużo czasu i wysiłku poświęcono opracowaniu systemu generowania liczb pseudolosowych (ang. PRNG - Pseudo Random Number Generator), który znalazł szerokie zastosowanie. Generowane liczby traktujemy jako pseudolosowe - tzn. jeśli znasz zawartośc pamięci komputera i algorytm PRNG możesz (przynajmniej teoretycznie) przewidzie jaka jest następna wartosc wygenerowanej liczby.\nZgodnie z zasadami fizyki zachwanie kubitu będącego w superpozycji w czasie dokonania pomiaru jest idealne i nieprzewidywalne. Dzięki temu już pojedynczy kubit pozwala wygenerowa najlepszy na świecie generator liczb losowych.\ninstrukcja\n\nPrzygotuj kubit w stanie początkowym \\(\\ket{0}\\).\nZastosuj bramkę Hadamarda tworząc z kubitu stan superpozycji stanów bazowych.\nWykonaj pomiar\n\nWłaśnie otrzymałeś QRNG - Quantum Random Number Generator. Nie jest to tani sposób na losow rzut monetą. Jednak trzeba miec swiadomośc, że tutaj nie ma wewnętrznego mechanizmu, który generuje losowośc - wynika ona tylko i wyłącznie z praw mechaniki kwantowej.\n\nCzy potrafisz wygenerowac losowy bajt?\n\n\n\nGra w obracanie monety\nWykorzystując powyżej zdefiniowane bramki możemy zrealizowa następującą grę:\n\nW grze bierze udział dwóch graczy. Gracze dysponują monetą, której nie widzą w trakcie gry (np. jest zamknięta w pudełku). Natomiast wiedzą, że początkowo moneta ułożona jest orłem do góry (w stanie \\(\\ket{0}\\)) Gra polega na wykonaniu trzech ruchów na przemian. Każdy ruch polega na odwróceniu monety bądź pozostawieniu jej w takim stanie w jakim była. Gracze nie wiedzą jaki ruch wykonuje przeciwnik. Po ostatnim ruchu pudełko zostaje otwarte i gracze sprawdzają w jakiej pozycji jest moneta. Pierwszy gracz wygrywa jeśli moneta jest w pozycji orła, a drugi jeśli przeciwnie.\n\nSzansa wygranej wynosi dla każdego \\(50\\%\\) i jak można sprawdzic nie istnieje strategia wygrywająca.\nPytanie zasadnicze - a co jeśli zamienimy monetę na kubit?\nMożliwe operacje pozostawienia kubitu w takim samym stanie - bramka I, zmiany stanu na przeciwny bramka X. Czyli pierwszy gracz ustala pierwszą bramkę, drugi drugą i ponownie pierwszy trzecią. Otwarcie pudełka to pomiar stanu kubitu.\n\nPrzeanalizuj wynik dla sekwencji I X I\n\nA co jeśli pierwszy gracz wie, że działa na kubicie?\n\nCzy może sprawic on, że wygra zawsze? (skoro wie, że działa na kubicie może użyc innych bramek)"
  },
  {
    "objectID": "lectures/wyklad4.html#bramki-dwukubitowe",
    "href": "lectures/wyklad4.html#bramki-dwukubitowe",
    "title": "Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych",
    "section": "Bramki dwukubitowe",
    "text": "Bramki dwukubitowe\nAnalogicznie do bramek jednokubitowych reprezentowanych przez macierze unitarne \\(2\\times 2\\) możemy skonstruowac dowolną wielo-kubitową bramkę. Dla n kubitów mamy \\(2^n \\times 2^n\\) unitarną macierz reprezentującą taką bramkę. Ponieważ bramki wielo kubiotwe działają na raz na kilka kubitów mogą służyc one do otrzymywania stanów splątanych. Mamy również możliwośc stworzyc bramkę warunkową (kontrolowaną), która zmienia bit docelowy jeśli kontrolny bit jest w stanie \\(\\ket{1}\\).\nW ogólności taka bramka może zostac zapisana jako: \\[\n\\textbf{CU}= \\ket{0}\\bra{0} \\otimes \\textbf{I} + \\ket{1}\\bra{1} \\otimes \\textbf{\\textbf{U}}\n\\]\nDowolna bramka działajaca na 1 kubit może byc przedstawiona jako mecierz \\[\n\\textbf{U} = \\begin{bmatrix} u_{00} \\, u_{01} \\\\ u_{10}\\, u_{11} \\end{bmatrix}\n\\]\ndlatego:\n\\[\n\\textbf{CU}=  \\begin{bmatrix} 1 \\,\\, \\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\, \\,\\,\\, 1 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\,\\,\\, 0\\,\\,\\,  u_{00} \\,\\, u_{01} \\\\ 0\\,\\,\\,\\, 0\\,\\,\\, u_{10}\\, \\, u_{11} \\end{bmatrix}\n\\]\nSzczegółowe działanie bramki można zapisac jako:\n\\[\\begin{align*}\n\\textbf{CU} \\ket{0} \\otimes \\ket{0} &=&  \\ket{0} \\otimes \\ket{0} \\\\\n\\textbf{CU} \\ket{0} \\otimes \\ket{1} &=& \\ket{0}\\otimes \\ket{1} \\\\\n\\textbf{CU} \\ket{1}\\otimes \\ket{0} &=& \\ket{1}\\otimes \\textbf{U} \\ket{0} \\\\\n\\textbf{CU} \\ket{1}\\otimes \\ket{1} &=& \\ket{1}\\otimes \\textbf{U} \\ket{1} \\\\\n\\end{align*}\\]\nDla kwantowej bramki NOT \\(\\textbf{U}= X\\) \\[\n\\text{CNOT} = \\begin{bmatrix} 1 \\,\\, \\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\, \\,\\,\\, 1 \\,\\,\\,\\,\\, 0 \\,\\,\\,\\,\\, 0 \\\\\n0\\,\\,\\,\\,\\, 0\\,\\,\\,\\,\\,  0 \\,\\,\\,\\,\\, 1 \\\\ 0\\,\\,\\,\\,\\, 0\\,\\,\\,\\,\\, 1\\,\\,\\,\\,\\, 0 \\end{bmatrix}\n\\] Bramka ta do drugiego kubitu (targetu) stosuje bramkę X jeśli pierwszy kubit jest w pozycji \\(\\ket{1}\\). W przeciwnym wypadku nie zmienia się nic.\n\\[\\begin{align*}\n\\textbf{CNOT} \\ket{0} \\otimes \\ket{0} &=&  \\ket{0} \\otimes \\ket{0} \\\\\n\\textbf{CNOT} \\ket{0} \\otimes \\ket{1} &=& \\ket{0}\\otimes \\ket{1} \\\\\n\\textbf{CNOT} \\ket{1}\\otimes \\ket{0} &=& \\ket{1}\\otimes \\ket{1} \\\\\n\\textbf{CNOT} \\ket{1}\\otimes \\ket{1} &=& \\ket{1}\\otimes \\ket{0} \\\\\n\\end{align*}\\]\n\nRozpoczynajac od stanu \\(\\ket{0} \\otimes \\ket{0}\\) zadziałaj na pierwszy kubit bramka Hadamarda a na tak otrzymany stan zadziałaj CNOT. Jaki stan uzyskujemy?"
  }
]