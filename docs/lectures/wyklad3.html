<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Wstęp do kwantowego uczenia maszynowego - Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../style.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Wstęp do kwantowego uczenia maszynowego</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html" rel="" target="">
 <span class="menu-text">232530-D</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../lectures/wyklad1.html" rel="" target="">
 <span class="menu-text">Wykład 1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../lectures/wyklad2.html" rel="" target="">
 <span class="menu-text">Wykład 2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="../lectures/wyklad3.html" rel="" target="" aria-current="page">
 <span class="menu-text">Wykład 3</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../sylabus.html" rel="" target="">
 <span class="menu-text">Sylabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../ksiazki.html" rel="" target="">
 <span class="menu-text">Książki</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#liczby-rzeczywiste-i-zespolone---przypomnienie" id="toc-liczby-rzeczywiste-i-zespolone---przypomnienie" class="nav-link active" data-scroll-target="#liczby-rzeczywiste-i-zespolone---przypomnienie">Liczby rzeczywiste i zespolone - przypomnienie</a></li>
  <li><a href="#wektory-i-przestrzenie-wektorowe" id="toc-wektory-i-przestrzenie-wektorowe" class="nav-link" data-scroll-target="#wektory-i-przestrzenie-wektorowe">Wektory i przestrzenie wektorowe</a>
  <ul class="collapse">
  <li><a href="#własności" id="toc-własności" class="nav-link" data-scroll-target="#własności">Własności</a></li>
  <li><a href="#wektory-kolumnowe" id="toc-wektory-kolumnowe" class="nav-link" data-scroll-target="#wektory-kolumnowe">Wektory kolumnowe</a></li>
  <li><a href="#wektory-wierszowe" id="toc-wektory-wierszowe" class="nav-link" data-scroll-target="#wektory-wierszowe">Wektory wierszowe</a></li>
  <li><a href="#transpozycja-i-sprzężenie-hermitowskie." id="toc-transpozycja-i-sprzężenie-hermitowskie." class="nav-link" data-scroll-target="#transpozycja-i-sprzężenie-hermitowskie.">Transpozycja i sprzężenie Hermitowskie.</a></li>
  <li><a href="#iloczyn-skalarny" id="toc-iloczyn-skalarny" class="nav-link" data-scroll-target="#iloczyn-skalarny">Iloczyn skalarny</a></li>
  <li><a href="#kombinacja-liniowa-wektorów" id="toc-kombinacja-liniowa-wektorów" class="nav-link" data-scroll-target="#kombinacja-liniowa-wektorów">Kombinacja liniowa wektorów</a></li>
  </ul></li>
  <li><a href="#formalizm-matematyczny-obliczeń-kwantowych" id="toc-formalizm-matematyczny-obliczeń-kwantowych" class="nav-link" data-scroll-target="#formalizm-matematyczny-obliczeń-kwantowych">Formalizm matematyczny obliczeń kwantowych</a></li>
  <li><a href="#stan" id="toc-stan" class="nav-link" data-scroll-target="#stan">Stan</a>
  <ul class="collapse">
  <li><a href="#kubit" id="toc-kubit" class="nav-link" data-scroll-target="#kubit">Kubit</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p><span class="math display">\[
\newcommand{\bra}[1]{\left \langle #1 \right \rvert}
\newcommand{\ket}[1]{\left \rvert #1 \right \rangle}
\newcommand{\braket}[2]{\left \langle #1 \middle \rvert #2 \right \rangle}
\]</span></p>
<p>Mechanika opiera się na <em>algebrze liniowej</em>. W ogólności teoria ta posługuje się pojęciem nieskończenie wymiarowej przestrzeni liniowej. Na szczęście do opisu kubitów (2-dim) i układów kwantowych (<span class="math inline">\(2^{n}\)</span>-dim) wystarczy nam pojęcie skończenie wymiarowej przestrzeni wektorowej. Bardzo upraszcza nam to naukę o kwantowym uczeniu maszynowym, gdyż wiele problemów matematycznych (dla fizyków) tutaj nie występuje. Upraszcza to również ilość potrzebnych matematycznych pojęć.</p>
<p>Będziemy posługiwali się notacją Diraca, jednego z twórców mechaniki kwantowej. W książce Ch.Bernhardta “Obliczenia kwantowe dla każdego” autor rezygnuje z liczb zespolonych, na rzecz liczb rzeczywistych. O ile podejście takie sprawdza się na poziomie opisu o tyle dla pełnego zrozumienia posługiwanie się liczbami zespolonymi jest niezbędne.</p>
<section id="liczby-rzeczywiste-i-zespolone---przypomnienie" class="level2">
<h2 class="anchored" data-anchor-id="liczby-rzeczywiste-i-zespolone---przypomnienie">Liczby rzeczywiste i zespolone - przypomnienie</h2>
<p>Liczby to matematyczne, abstrakcyjne pojęcie wywodzące się z teorii mnogości (zbiorów). Przykładowo liczba 42 zapisywana w postaci zapisu dziesiętnego lub binarnego <span class="math inline">\(42=101010_2\)</span>. Można oczywiście znaleźć 42 przedmioty i je przeliczyć jednak w naszym przypadku skupimy się na abstrakcyjnym pojęciu niezależnym od jego reprezentacji. Liczba 42 jest liczbą naturalną. Zbiór liczb naturalnych oznaczamy jako <span class="math inline">\(\mathbb{N}\)</span>. Identyczne własności abstrakcji mają liczby całkowite <span class="math inline">\(\mathbb{Z}\)</span>, wymierne <span class="math inline">\(\mathbb{Q}\)</span>, rzeczywiste <span class="math inline">\(\mathbb{R}\)</span> i zespolone <span class="math inline">\(\mathbb{C}\)</span>. Nie możemy liczb zobaczyć czy dotknąć, ale możemy na nich wykonywać operacje matematyczne. Liczby zespolone nie są bardziej abstrakcyjne niż liczby rzeczywiste, czy naturalne.</p>
<p>Liczba zespolona (we współrzędnych Kartezjańskich) <span class="math inline">\(z=x + i y\)</span> składa się z części rzeczywistej <span class="math inline">\(R(z)=x\)</span> i urojonej <span class="math inline">\(I(z)=y\)</span>. gdzie <span class="math display">\[i^2=-1\]</span>.</p>
<p><span class="math display">\[1+i\sqrt{3}\]</span> <span class="math inline">\(R(z)=1\)</span> i <span class="math inline">\(I(z)=\sqrt{3}\)</span>.</p>
<p>Każdą liczbę zespoloną możemy zapisać w postaci polarnej <span class="math inline">\(z=r e^{i \theta}\)</span>, gdzie <span class="math inline">\(r=|z|\)</span> to moduł liczby zespolonej, a <span class="math inline">\(\theta\)</span> to jej argument. <span class="math display">\[ z = r e^{i \theta} = r (\cos{\theta} + i \sin{\theta})\]</span> gdzie: <span class="math display">\[r = |z| = \sqrt{x^2 + y^2}\]</span> <span class="math display">\[\theta = \arctan{\frac{y}{x}}\]</span> Natomiast: <span class="math display">\[x = r \cos{\theta}\]</span> <span class="math display">\[y = r \sin{\theta}\]</span></p>
<p>Dla naszego przykładu: <span class="math display">\[1+i\sqrt{3} = 2 e^{i \frac{\pi}{3}}\]</span></p>
<blockquote class="blockquote">
<p>Udowodnij samodzielnie, że powyższe równanie jest prawdziwe.</p>
</blockquote>
<p><strong>Liczba sprzężona</strong> do liczby zespolonej <span class="math inline">\(z=x + i y\)</span> to <span class="math inline">\(z^*=x - i y = r*e^{-i \theta}\)</span>.</p>
<p><strong>Norma</strong> liczby zespolonej <span class="math inline">\(z=x + i y\)</span> to <span class="math inline">\(|z|=\sqrt{x^2 + y^2}=r\)</span>.</p>
<p><strong>Kwadrat normy</strong> liczby zespolonej <span class="math inline">\(z=x + i y\)</span> to <span class="math inline">\(|z|^2=x^2 + y^2=r^2\)</span>. Można go również zapisać jako <span class="math inline">\(|z|=z z^* = z^* z\)</span>.</p>
<blockquote class="blockquote">
<p>Udowodnij w kartezjańskim i polarnym układzie oniesienia.</p>
</blockquote>
<p>Dodawanie licz zespolonych jest zdefiniowane jako dodawanie poszczególnych składników.</p>
<blockquote class="blockquote">
<p>ile wynosi <span class="math inline">\(z_1 z_2\)</span>?</p>
</blockquote>
<blockquote class="blockquote">
<p>ile wynosi <span class="math inline">\(\frac{z_1}{z_2}\)</span></p>
</blockquote>
</section>
<section id="wektory-i-przestrzenie-wektorowe" class="level2">
<h2 class="anchored" data-anchor-id="wektory-i-przestrzenie-wektorowe">Wektory i przestrzenie wektorowe</h2>
<p>Niech dany będzie zbiór <span class="math inline">\(\mathbb{V}\)</span> oraz zbiór <span class="math inline">\(\mathbb{K}\)</span>. Elementy zbioru <span class="math inline">\(\mathbb{V}\)</span> można ze sobą dodawać i mnożyć przez elementy zbioru <span class="math inline">\(\mathbb{K}\)</span>. Wraz z dodatkowymi opracjami (zdefiniowanymi poniżej) zbiór ten będziemy nazwywali <strong>przestrzenią wektorową</strong>. Jej elementy to <strong>wektory</strong>.</p>
<p>Uwaga wektory będziemy oznaczać jako <span class="math inline">\(\ket{v}\)</span>. Będą to kolekcje liczb. Jeśli liczby te będą rzeczywiste to będziemy mówić o <strong>przestrzeni wektorowej rzeczywistej</strong>. Natomiast jeśli liczby te będą zespolone to będziemy mówić o <strong>przestrzeni wektorowej zespolonej</strong>.</p>
<p>Myśląc o wektorach często wyobrażamy je sobie jako strzałki w przestrzeni. Tak nas nauczono jednak nie jest to prawdziwe. Na tych zajęciach wektory będą reprezentowane jako abstrakcyjne elementy przestrzeni wektorowej. Warto jednak pamiętać, że wszystkie własności (algebraiczne) wektorów są również spełnione dla strzałek.</p>
<section id="własności" class="level3">
<h3 class="anchored" data-anchor-id="własności">Własności</h3>
<ol type="1">
<li><p>Istnieje szczególny (i jedyny) wektor <span class="math inline">\(\ket{0}\)</span> zerowy. Niech <span class="math inline">\(\ket{v}\)</span> , <span class="math inline">\(\ket{u}\)</span>, <span class="math inline">\(\ket{z}\)</span> będą dowolnymi wektorami, natomiast <span class="math inline">\(\alpha\)</span> i <span class="math inline">\(\beta\)</span> dowolnymi liczbami.</p></li>
<li><p>Dodawanie wektorów jest przemienne: <span class="math display">\[\ket{v} + \ket{u} = \ket{u} + \ket{v}\]</span></p></li>
<li><p>Dodawanie wektorów jest łączne: <span class="math display">\[\ket{v} + (\ket{u} + \ket{z}) = (\ket{v} + \ket{u}) + \ket{z}\]</span></p></li>
<li><p>Istnieje szczególny (i jedyny) wektor <span class="math inline">\(\ket{v}\)</span> odwrotny do wektora <span class="math inline">\(\ket{u}\)</span>: <span class="math display">\[\ket{v} + \ket{u} = \ket{0}\]</span></p></li>
<li><p>Dla każdego wektora <span class="math inline">\(\ket{v}\)</span> zachodzi: <span class="math display">\[\ket{v} + \ket{0} = \ket{0} + \ket{v} = \ket{v}\]</span></p></li>
<li><p>1*wektor = wektor: <span class="math display">\[1 \ket{v} = \ket{v}\]</span></p></li>
<li><p>łączność mnożenia przez skalar: <span class="math display">\[\alpha (\beta \ket{v}) = (\alpha \beta) \ket{v}\]</span></p></li>
<li><p>Rozdzielność mnożenia przez skalar względem dodawania wektorów: <span class="math display">\[\alpha (\ket{v} + \ket{u}) = \alpha \ket{v} + \alpha \ket{u}\]</span></p></li>
<li><p>Rozdzielność&nbsp;dodawania skalarów względem mnożenia przez wektor: <span class="math display">\[(\alpha + \beta) \ket{v} = \alpha \ket{v} + \beta \ket{v}\]</span></p></li>
</ol>
</section>
<section id="wektory-kolumnowe" class="level3">
<h3 class="anchored" data-anchor-id="wektory-kolumnowe">Wektory kolumnowe</h3>
<p>Zapiszmy pionową jednokolumnową tablicę liczb: <span class="math display">\[ \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix} \]</span></p>
<p>Mnożenie przez liczbę: <span class="math display">\[ \alpha \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix} = \begin{bmatrix} \alpha x_1 \\ \alpha x_2 \\ .\\ \alpha x_n \end{bmatrix} \]</span></p>
<p>Dodawanie kolumn: <span class="math display">\[ \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix} + \begin{bmatrix} y_1 \\ y_2 \\ .\\ y_n \end{bmatrix} = \begin{bmatrix} x_1+y_1 \\ x_2+y_2 \\ .\\ x_n+y_n \end{bmatrix}\]</span></p>
<p>Pozwala to otrzymać konkretną <em>reprezentację</em> wektorów, które będziemy oznaczać w notacji Diraca przez “ket” <span class="math inline">\(\ket{.}\)</span>.</p>
</section>
<section id="wektory-wierszowe" class="level3">
<h3 class="anchored" data-anchor-id="wektory-wierszowe">Wektory wierszowe</h3>
<p><span class="math display">\[ \begin{bmatrix} x_1  x_2 \dots x_n \end{bmatrix}\]</span>. Analogicznie do poprzedniego przykładu łatwo określić jak dodawać je ze sobą i mnożyć przez liczbę. W notacji Diraca będziemy takie wektory oznaczali przez “bra” <span class="math inline">\(\bra{.}\)</span>.</p>
</section>
<section id="transpozycja-i-sprzężenie-hermitowskie." class="level3">
<h3 class="anchored" data-anchor-id="transpozycja-i-sprzężenie-hermitowskie.">Transpozycja i sprzężenie Hermitowskie.</h3>
<p>Transpozycja <span class="math inline">\(T\)</span> Zamienia wektory wierszowe na kolumnowe i odwrotnie. Natomiast sprzężenie hermitowskie <span class="math inline">\(\dagger\)</span> dodatkowo dodaje sprzężenie zespolone.</p>
<p><span class="math display">\[\ket{u}^{\dagger} = \bra{u}\]</span> <span class="math display">\[\bra{u}^{\dagger} = \ket{u}\]</span></p>
</section>
<section id="iloczyn-skalarny" class="level3">
<h3 class="anchored" data-anchor-id="iloczyn-skalarny">Iloczyn skalarny</h3>
<p>Iloczynem skalarnym dwóch wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> nazywany funkcję, która zwraca liczbę.</p>
<ul>
<li><span class="math inline">\(\braket{u}{v} = \braket{v}{u}^{\ast}\)</span></li>
<li><span class="math inline">\((\alpha \bra{u})\ket{v} = \alpha \braket{u}{v}\)</span></li>
<li><span class="math inline">\((\bra{u} + \bra{v}) \ket{z} = \braket{u}{z} +\braket{v}{z}\)</span></li>
<li><span class="math inline">\(\braket{u}{u} &gt; 0\)</span></li>
<li><span class="math inline">\(\braket{u}{u} = 0, gdy \ket{u}=\ket{0}\)</span></li>
</ul>
<p>Dla dwóch wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> otrzymujemy: <span class="math display">\[ \ket{u} = \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix}, \ket{v} = \begin{bmatrix} y_1 \\ y_2 \\ .\\ y_n \end{bmatrix} \]</span></p>
<p><span class="math display">\[ \braket{u}{v} = x_1^{*}y_1 +x_2^{*}y_2 + \dots + x_n^{*}y_n\]</span></p>
</section>
<section id="kombinacja-liniowa-wektorów" class="level3">
<h3 class="anchored" data-anchor-id="kombinacja-liniowa-wektorów">Kombinacja liniowa wektorów</h3>
<p>Dla dwóch wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> oraz dwóch liczb <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> możemy stworzyć nowy wektor: <span class="math display">\[\ket{z} = \alpha \ket{u} + \beta \ket{v}\]</span> Wektor ten nazywamy kombinacją liniową wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span>.</p>
</section>
</section>
<section id="formalizm-matematyczny-obliczeń-kwantowych" class="level2">
<h2 class="anchored" data-anchor-id="formalizm-matematyczny-obliczeń-kwantowych">Formalizm matematyczny obliczeń kwantowych</h2>
<p>Ta wiedza wystarczy do wyjaśnienia <em>notacji Diraca</em>.</p>
<p>Iloczyn skalarny <span class="math inline">\(\braket{\psi}{\phi}\)</span> wektorów <span class="math inline">\(\ket{\psi}\)</span> i <span class="math inline">\(\ket{\phi}\)</span> czytamy jako <em>braket u v</em>.</p>
</section>
<section id="stan" class="level2">
<h2 class="anchored" data-anchor-id="stan">Stan</h2>
<p>Stanem w mechanice kwantowej nazywamy wektor: <span class="math display">\[\ket{\phi} = begin{bmatrix} \alpha_0 \\ \alpha_1 \\ .\\ \alpha_{n-1} \end{bmatrix}\]</span></p>
<p>Chcemy aby współczynniki <span class="math inline">\(\alpha_i\)</span> były liczbami zespolonymi a cały wektor był unormowany do 1.</p>
<p>Liczby <span class="math inline">\(\alpha_i\)</span> nazywamy <strong>amplitudami prawdopodobieństwa</strong> stanu kwantowego. Jeśli przynajmniej dwie liczby <span class="math inline">\(\alpha_i\)</span> są niezerowe, to układ znajduje się w <strong>superpozycji</strong> stanów.</p>
<section id="kubit" class="level3">
<h3 class="anchored" data-anchor-id="kubit">Kubit</h3>
<p>Elementarnym obiektem w informatyce kwantowej jest <em>kubit</em>, który realizowany jest jako dwu wymiarowy układ kwantowy. Stan kwantowy kubitu opisuje <strong>wektor</strong> w przestrzeni liniowej <span class="math inline">\(\mathbb{C}^2\)</span>.</p>
<p>W celu wykonywania obliczeń i opisu stanu kubitu wybierzemy tzw. bazę obliczeniową: <span class="math display">\[\ket{0} = \begin{bmatrix} 1 \\ 0  \end{bmatrix} , \ket{1} = \begin{bmatrix} 0 \\ 1  \end{bmatrix}\]</span></p>
<p>To co wyróżnia kubit w porównaniu do klasycznego bitu dowolny stan <span class="math inline">\(\ket{\psi}\)</span> może być superpozycją stanów bazowych: <span class="math display">\[\ket{\psi} = \alpha \ket{0} + \beta \ket{1}\]</span> dla którego zachodzi warunek normalizacji: <span class="math display">\[\braket{\psi}{\psi} = |\alpha|^2 + |\beta|^2 = 1\]</span> i <span class="math inline">\(\alpha, \beta \in \mathbb{C}\)</span>.</p>
<p>Liczby <span class="math inline">\(\alpha\)</span> i <span class="math inline">\(\beta\)</span> są zespolone, zatem potrzeba 4 liczb rzeczywistych aby je opisać. Ze względu na warunek normalizacji wystarczą 3 liczby rzeczywiste. Czwartą liczbę możemy obliczyć.</p>
<p>Stan kubitu możemy zapisać w postaci: <span class="math display">\[\ket{\psi} = e^{i \gamma}\left( \cos{\frac{\theta}{2}} \ket{0} + e^{i \phi} \sin{\frac{\theta}{2}} \ket{1} \right)\]</span> gdzie <span class="math inline">\(\theta \in [0, \pi]\)</span>, <span class="math inline">\(\phi \in [0, 2\pi]\)</span> i <span class="math inline">\(\gamma \in [0, 2\pi]\)</span> są liczbami rzeczywistymi.</p>
<p>Współczynnik <span class="math inline">\(e^{i \gamma}\)</span> nazywamy <em>fazą globalną</em>. Ze względu, iż analizować będziemy kwadraty amplitud prawdopodobieństwa to faza globalna nie ma znaczenia. Dlatego możemy napisać: <span class="math display">\[\ket{\psi} = \cos{\frac{\theta}{2}} \ket{0} + e^{i \phi} \sin{\frac{\theta}{2}} \ket{1}\]</span></p>
<p>Warto zauważyć, że dwa dowolne stany kubitów <span class="math inline">\(\ket{\psi}\)</span> i <span class="math inline">\(\ket{\phi}\)</span> różnią się o czynnik fazowy <span class="math inline">\(e^{i \gamma}\)</span> to stany te dają identyczne wyniki.</p>
<p>Liczby rzeczywiste <span class="math inline">\(\theta\)</span> i <span class="math inline">\(\phi\)</span> nazywamy <em>kątami</em> kubitu i możemy interpretować je jako współrzędne na <strong>sferze Blocha</strong>. Bardzo często będziemy wykorzystywać ją do wizualizacji stanów kubitów.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>