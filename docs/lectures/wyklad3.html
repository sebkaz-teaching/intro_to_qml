<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.450">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Wstęp do kwantowego uczenia maszynowego - Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../style.css">
</head>

<body class="nav-sidebar docked nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Wstęp do kwantowego uczenia maszynowego</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../sylabus.html" rel="" target="">
 <span class="menu-text">Sylabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../ksiazki.html" rel="" target="">
 <span class="menu-text">Książki</span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools ms-auto">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
      <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../lectures/wyklad1.html">Wykłady</a></li><li class="breadcrumb-item"><a href="../lectures/wyklad3.html">Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</a></li></ol></nav>
      <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
      </a>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal sidebar-navigation docked overflow-auto">
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Informacje ogólne</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true">
 <span class="menu-text">Wykłady</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Komputery klasyczne i kwantowe</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Klasyczne bramki logiczne - Algebra Boola</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad3.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../lectures/wyklad4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Kwantowe bramki logiczne w prostych algorytmach i obwodach kwantowych</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true">
 <span class="menu-text">Ćwiczenia</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/cw1.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Biblioteka Qiskit wprowadzenie</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/cw2.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bramki jednokubitowe</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/cw3.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Bramki wielokubitowe</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/cw4.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Algorytmy kwantowe - przegląd</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/cw5.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Parameterized Quantum Circuit</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/ml.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Kwantowy model klasyfikatora wariacyjnego</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../cwiczenia/titanic.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Titanic data</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar,#quarto-sidebar-glass"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#liczby-rzeczywiste-i-zespolone---przypomnienie" id="toc-liczby-rzeczywiste-i-zespolone---przypomnienie" class="nav-link active" data-scroll-target="#liczby-rzeczywiste-i-zespolone---przypomnienie">Liczby rzeczywiste i zespolone - przypomnienie</a></li>
  <li><a href="#wektory-i-przestrzenie-wektorowe" id="toc-wektory-i-przestrzenie-wektorowe" class="nav-link" data-scroll-target="#wektory-i-przestrzenie-wektorowe">Wektory i przestrzenie wektorowe</a>
  <ul class="collapse">
  <li><a href="#aksjomaty-przestrzeni-stanów" id="toc-aksjomaty-przestrzeni-stanów" class="nav-link" data-scroll-target="#aksjomaty-przestrzeni-stanów">Aksjomaty przestrzeni stanów</a></li>
  <li><a href="#wektory-kolumnowe" id="toc-wektory-kolumnowe" class="nav-link" data-scroll-target="#wektory-kolumnowe">Wektory kolumnowe</a></li>
  <li><a href="#wektory-wierszowe" id="toc-wektory-wierszowe" class="nav-link" data-scroll-target="#wektory-wierszowe">Wektory wierszowe</a></li>
  <li><a href="#transpozycja-i-sprzężenie-hermitowskie." id="toc-transpozycja-i-sprzężenie-hermitowskie." class="nav-link" data-scroll-target="#transpozycja-i-sprzężenie-hermitowskie.">Transpozycja i sprzężenie Hermitowskie.</a></li>
  <li><a href="#iloczyn-skalarny" id="toc-iloczyn-skalarny" class="nav-link" data-scroll-target="#iloczyn-skalarny">Iloczyn skalarny</a></li>
  <li><a href="#kombinacja-liniowa-wektorów" id="toc-kombinacja-liniowa-wektorów" class="nav-link" data-scroll-target="#kombinacja-liniowa-wektorów">Kombinacja liniowa wektorów</a></li>
  <li><a href="#baza" id="toc-baza" class="nav-link" data-scroll-target="#baza">Baza</a></li>
  </ul></li>
  <li><a href="#formalizm-matematyczny-obliczeń-kwantowych" id="toc-formalizm-matematyczny-obliczeń-kwantowych" class="nav-link" data-scroll-target="#formalizm-matematyczny-obliczeń-kwantowych">Formalizm matematyczny obliczeń kwantowych</a>
  <ul class="collapse">
  <li><a href="#stan" id="toc-stan" class="nav-link" data-scroll-target="#stan">Stan</a></li>
  <li><a href="#kubit" id="toc-kubit" class="nav-link" data-scroll-target="#kubit">Kubit</a></li>
  <li><a href="#dwa-kubity" id="toc-dwa-kubity" class="nav-link" data-scroll-target="#dwa-kubity">Dwa kubity</a></li>
  <li><a href="#stan-separowalny-i-splątany" id="toc-stan-separowalny-i-splątany" class="nav-link" data-scroll-target="#stan-separowalny-i-splątany">Stan separowalny i splątany</a></li>
  </ul></li>
  <li><a href="#pomiar-w-bazie-z" id="toc-pomiar-w-bazie-z" class="nav-link" data-scroll-target="#pomiar-w-bazie-z">Pomiar w bazie Z</a>
  <ul class="collapse">
  <li><a href="#przykład" id="toc-przykład" class="nav-link" data-scroll-target="#przykład">Przykład</a></li>
  </ul></li>
  <li><a href="#kilka-ciekawostek-matematycznych" id="toc-kilka-ciekawostek-matematycznych" class="nav-link" data-scroll-target="#kilka-ciekawostek-matematycznych">Kilka ciekawostek matematycznych</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Przestrzenie wektorowe, stany kwantowe, reprezentacja klasycznych i kwantowych bitów</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p><span class="math display">\[
\newcommand{\bra}[1]{\left \langle #1 \right \rvert}
\newcommand{\ket}[1]{\left \rvert #1 \right \rangle}
\newcommand{\braket}[2]{\left \langle #1 \middle \rvert #2 \right \rangle}
\]</span></p>
<p>Mechanika Kwantowa opiera się na <em>algebrze liniowej</em>. W ogólności teoria ta posługuje się pojęciem nieskończenie wymiarowej przestrzeni liniowej. Na szczęście do opisu kubitów (2-dim) i układów kwantowych (<span class="math inline">\(2^{n}\)</span>-dim) wystarczy nam pojęcie skończenie wymiarowej przestrzeni wektorowej. Bardzo upraszcza nam to naukę o kwantowym uczeniu maszynowym, gdyż wiele problemów matematycznych (dla fizyków) tutaj nie występuje. Upraszcza to również ilość potrzebnych matematycznych pojęć.</p>
<p>Będziemy posługiwali się notacją Diraca, jednego z twórców mechaniki kwantowej. W książce Ch. Bernhardta “Obliczenia kwantowe dla każdego” autor rezygnuje z liczb zespolonych, na rzecz liczb rzeczywistych. O ile podejście takie sprawdza się na poziomie opisu o tyle dla pełnego zrozumienia posługiwanie się liczbami zespolonymi jest niezbędne.</p>
<section id="liczby-rzeczywiste-i-zespolone---przypomnienie" class="level2">
<h2 class="anchored" data-anchor-id="liczby-rzeczywiste-i-zespolone---przypomnienie">Liczby rzeczywiste i zespolone - przypomnienie</h2>
<p>Liczby to matematyczne, abstrakcyjne pojęcia wywodzące się z teorii mnogości (zbiorów). Przykładowo, liczbę 42 można zapisa w postaci dziesiętnej lub binarnej <span class="math inline">\(42=101010_2\)</span>. Możemy znaleźć 42 przedmioty i je przeliczyć, ale w naszym przypadku skupimy się na abstrakcyjnym pojęciu liczby, niezależnie od jej reprezentacji. Liczba 42 jest liczbą naturalną. Zbiór liczb naturalnych oznaczamy jako <span class="math inline">\(\mathbb{N}\)</span>. Identyczne cechy abstrakcji mają liczby całkowite <span class="math inline">\(\mathbb{Z}\)</span>, liczby wymierne <span class="math inline">\(\mathbb{Q}\)</span>, liczby rzeczywiste <span class="math inline">\(\mathbb{R}\)</span> oraz liczby zespolone <span class="math inline">\(\mathbb{C}\)</span>. Nie możemy zobaczyć ani dotknąć liczb, ale możemy wykonywać na nich operacje matematyczne. Liczb Warto zaznaczyc,że liczby zespolone nie są bardziej abstrakcyjne niż liczby rzeczywiste, czy naturalne.</p>
<p>Liczba zespolona (we współrzędnych Kartezjańskich) składa się z (dwóch liczb rzeczywistych) części rzeczywistej i urojonej: <span class="math display">\[z=x + i y\]</span> gdzie <span class="math inline">\(i^2=-1\)</span>.</p>
<p>Natomiast częśc rzeczywista <span class="math inline">\(R(z)=x\)</span> i częśc urojona <span class="math inline">\(I(z)=y\)</span>.</p>
<p>Na przykład: <span class="math display">\[1+i\sqrt{3}\]</span> <span class="math inline">\(R(z)=1\)</span> i <span class="math inline">\(I(z)=\sqrt{3}\)</span>.</p>
<p>Inaczej mówiąc, liczba zespolona jest sumą liczby rzeczywistej i urojonej.</p>
<p>Liczy zespolone, można traktowac jako punkty na płaszczyźnie o współrzędnych <span class="math inline">\(x\)</span> i <span class="math inline">\(y\)</span>.</p>
<p><img class="center" src="../img/im_liczba.png"></p>
<p>Każdą liczbę zespoloną możemy zapisać w postaci polarnej (współrzędne biegunowe) <span class="math display">\[ z=r\, e^{i \phi} , \]</span> gdzie <span class="math inline">\(r=|z|\)</span> to moduł liczby zespolonej, a <span class="math inline">\(\phi\)</span> to jej argument czyli wyrażony w radianach kąt między osią rzeczywistą a półprostą poprowadzoną od środka ukł. wsp. i przechodzącą przez punkt <span class="math inline">\(z\)</span>. <span class="math display">\[ z = r\, e^{i \, \phi} = r\, (\cos{\phi} + i\, \sin{\phi})\]</span> gdzie: <span class="math display">\[r = |z| = \sqrt{x^2 + y^2}\]</span> <span class="math display">\[\phi = \arctan{\frac{y}{x}}. \]</span> Natomiast: <span class="math display">\[x = r \cos{\phi}\]</span> <span class="math display">\[y = r \sin{\phi}\]</span></p>
<p>Dla naszego przykładu: <span class="math display">\[1+i\sqrt{3} = 2 e^{i \frac{\pi}{3}} . \]</span></p>
<blockquote class="blockquote">
<p>Udowodnij samodzielnie, że powyższe równanie jest prawdziwe.</p>
</blockquote>
<p>Liczby zespolone można dodawa, mnożyc i dzieli zgodnie z zwykłymi regułami arytmetyki. Dodawanie liczb zespolonych jest łatwe dla liczb w postaci kartezjańskiej. Natomiast mnożenie liczb zespolonych upraszcza się dla postaci biegunowej (następuje zamiana mnożenia na dodawanie fazy).</p>
<p><strong>Liczba sprzężona</strong> do liczby zespolonej powstaje poprzez zmianę znaku części urojonej</p>
<p><span class="math inline">\(z=x + i\, y\,\,\,\,\)</span> to <span class="math inline">\(\,\,\,z^*=x - i y = r*e^{-i \phi}\)</span>.</p>
<p><strong>Norma</strong> liczby zespolonej <span class="math inline">\(z=x + i y\,\,\,\,\)</span> to <span class="math inline">\(\,\,\,|z|=\sqrt{x^2 + y^2}=r\)</span>.</p>
<p><strong>Kwadrat normy</strong> liczby zespolonej <span class="math inline">\(z=x + i y\,\,\,\,\)</span> to <span class="math inline">\(\,\,\, |z|^2=x^2 + y^2=r^2\)</span>. Warto zauważyc, że każdy kwadrat modułu daje w wyniku nieujemną liczbę rzeczywistą.</p>
<p>Można go również zapisać jako <span class="math display">\[|z|^2=z z^* = z^* z\]</span></p>
<p><strong>Czynniki fazowe</strong> to szczególna klasa liczb zespolonych <span class="math inline">\(z\)</span> dla której <span class="math inline">\(r=1\)</span>.</p>
<p>Otrzymujemy wtedy: <span class="math display">\[
z=e^{i \phi}=\cos{\phi} + i\, \sin{\phi}\]</span> <span class="math display">\[
z z^* = 1
\]</span></p>
<blockquote class="blockquote">
<p>Udowodnij w kartezjańskim i polarnym układzie oniesienia.</p>
</blockquote>
<blockquote class="blockquote">
<p>ile wynosi <span class="math inline">\(z_1 z_2\)</span></p>
</blockquote>
<blockquote class="blockquote">
<p>ile wynosi <span class="math inline">\(\frac{z_1}{z_2}\)</span></p>
</blockquote>
</section>
<section id="wektory-i-przestrzenie-wektorowe" class="level2">
<h2 class="anchored" data-anchor-id="wektory-i-przestrzenie-wektorowe">Wektory i przestrzenie wektorowe</h2>
<p>Niech dany będzie zbiór <span class="math inline">\(\mathbb{V}\)</span> oraz zbiór <span class="math inline">\(\mathbb{K}\)</span>. Elementy zbioru <span class="math inline">\(\mathbb{V}\)</span> można ze sobą dodawać i mnożyć przez elementy zbioru <span class="math inline">\(\mathbb{K}\)</span>. Wraz z dodatkowymi opracjami (zdefiniowanymi poniżej) zbiór ten będziemy nazwywali <strong>przestrzenią wektorową</strong>. Jej elementy to <strong>wektory ket</strong> <span class="math inline">\(\ket{u}\)</span> (lub kety).</p>
<p>Jeśli współczynniki liczbowe wektorów będą rzeczywiste to będziemy mówić o <strong>przestrzeni wektorowej rzeczywistej</strong>. Natomiast jeśli liczby te będą zespolone to będziemy mówić o <strong>przestrzeni wektorowej zespolonej</strong>.</p>
<p>Myśląc o wektorach często wyobrażamy je sobie jako strzałki w przestrzeni. Przez strzałki rozumiemy tutaj obiekty znajdujące się w zwykłej przestrzeni i posiadające wielkoś oraz kierunek. Wektory takie mają trzy składowe - trzy (rzeczywiste) współrzędne przestrzenne.</p>
<p>Na tych zajęciach lepiej zapomniec o tej koncepcji. Wszystkie wektory będą reprezentowane jako abstrakcyjne elementy przestrzeni wektorowej. Warto jednak pamiętać, że wszystkie własności (algebraiczne) wektorów są również spełnione dla strzałek.</p>
<section id="aksjomaty-przestrzeni-stanów" class="level3">
<h3 class="anchored" data-anchor-id="aksjomaty-przestrzeni-stanów">Aksjomaty przestrzeni stanów</h3>
<p>Niech <span class="math inline">\(\ket{v}\)</span> , <span class="math inline">\(\ket{u}\)</span>, <span class="math inline">\(\ket{z}\)</span> będą dowolnymi wektorami, natomiast <span class="math inline">\(\alpha\)</span> i <span class="math inline">\(\beta\)</span> dowolnymi liczbami.</p>
<ol type="1">
<li><p>Suma dwóch wektorów ket jest wektorem ket <span class="math display">\[\ket{v} + \ket{u} = \ket{z}\]</span></p></li>
<li><p>Dodawanie wektorów jest przemienne: <span class="math display">\[\ket{v} + \ket{u} = \ket{u} + \ket{v}\]</span></p></li>
<li><p>Dodawanie wektorów jest łączne: <span class="math display">\[\ket{v} + (\ket{u} + \ket{z}) = (\ket{v} + \ket{u}) + \ket{z}\]</span></p></li>
<li><p>Istnieje szczególny (i jedyny) wektor <span class="math inline">\(\ket{v}\)</span> odwrotny do wektora <span class="math inline">\(\ket{u}\)</span>: <span class="math display">\[\ket{v} + \ket{u} = 0\]</span></p></li>
<li><p>Istnieje szczególny (i jedyny) wektor <span class="math inline">\(0\)</span> zerowy. Dla każdego wektora <span class="math inline">\(\ket{v}\)</span> zachodzi: <span class="math display">\[\ket{v} + 0 = 0 + \ket{v} = \ket{v}\]</span></p></li>
<li><p>1*wektor = wektor: <span class="math display">\[1 \ket{v} = \ket{v}\]</span></p></li>
<li><p>Łączność mnożenia przez skalar: <span class="math display">\[\alpha (\beta \ket{v}) = (\alpha \beta) \ket{v}\]</span></p></li>
<li><p>Rozdzielność mnożenia przez skalar względem dodawania wektorów: <span class="math display">\[\alpha (\ket{v} + \ket{u}) = \alpha \ket{v} + \alpha \ket{u}\]</span></p></li>
<li><p>Rozdzielność&nbsp;dodawania skalarów względem mnożenia przez wektor: <span class="math display">\[(\alpha + \beta) \ket{v} = \alpha \ket{v} + \beta \ket{v}\]</span></p></li>
</ol>
</section>
<section id="wektory-kolumnowe" class="level3">
<h3 class="anchored" data-anchor-id="wektory-kolumnowe">Wektory kolumnowe</h3>
<p>Zapiszmy pionową jednokolumnową tablicę liczb: <span class="math display">\[ \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix} \]</span></p>
<p>Mnożenie przez liczbę: <span class="math display">\[ \alpha \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix} = \begin{bmatrix} \alpha x_1 \\ \alpha x_2 \\ .\\ \alpha x_n \end{bmatrix} \]</span></p>
<p>Dodawanie kolumn: <span class="math display">\[ \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix} + \begin{bmatrix} y_1 \\ y_2 \\ .\\ y_n \end{bmatrix} = \begin{bmatrix} x_1+y_1 \\ x_2+y_2 \\ .\\ x_n+y_n \end{bmatrix}\]</span></p>
<p>Pozwala to otrzymać konkretną <em>reprezentację</em> wektorów, które będziemy oznaczać w notacji Diraca przez “ket” <span class="math inline">\(\ket{.}\)</span>.</p>
</section>
<section id="wektory-wierszowe" class="level3">
<h3 class="anchored" data-anchor-id="wektory-wierszowe">Wektory wierszowe</h3>
<p><span class="math display">\[ \begin{bmatrix} x_1 \,\, x_2 \,\, \dots \,\, x_n \end{bmatrix}\]</span></p>
<p>Analogicznie do poprzedniego przykładu łatwo określić jak dodawać je ze sobą i mnożyć przez liczbę. W notacji Diraca będziemy takie wektory oznaczali przez “bra” <span class="math inline">\(\bra{.}\)</span>.</p>
</section>
<section id="transpozycja-i-sprzężenie-hermitowskie." class="level3">
<h3 class="anchored" data-anchor-id="transpozycja-i-sprzężenie-hermitowskie.">Transpozycja i sprzężenie Hermitowskie.</h3>
<p>Transpozycja <span class="math inline">\(T\)</span> Zamienia wektory wierszowe na kolumnowe i odwrotnie.</p>
<p><span class="math display">\[ \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix}^{T} = \begin{bmatrix} x_1 \,\, x_2 \,\, \dots \,\, x_n \end{bmatrix}\]</span></p>
<p>oraz <span class="math display">\[ \begin{bmatrix} x_1 \,\, x_2 \,\, \dots \,\, x_n \end{bmatrix}^{T} = \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix}\]</span></p>
<p>Natomiast sprzężenie hermitowskie <span class="math inline">\(\dagger = T \ast\)</span> dodatkowo do transpozycji dodaje sprzężenie zespolone.</p>
<p><span class="math display">\[\ket{u}^{\dagger} = \bra{u}\]</span> <span class="math display">\[\bra{u}^{\dagger} = \ket{u}\]</span></p>
<p>Czyli: <span class="math display">\[ (\ket{u} + \ket{v})^{\dagger} = \bra{u} + \bra{v} \]</span> oraz <span class="math display">\[ \alpha \ket{u} \to \bra{u} \alpha^*\]</span></p>
<p><span class="math display">\[ \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix}^{\dagger} = \begin{bmatrix} x_1^* \,\, x_2^* \,\, \dots \,\, x_n^* \end{bmatrix}\]</span></p>
<p>oraz <span class="math display">\[ \begin{bmatrix} x_1 \,\, x_2 \,\, \dots \,\, x_n \end{bmatrix}^{\dagger} = \begin{bmatrix} x_1^* \\ x_2^* \\ .\\ x_n^* \end{bmatrix}\]</span></p>
</section>
<section id="iloczyn-skalarny" class="level3">
<h3 class="anchored" data-anchor-id="iloczyn-skalarny">Iloczyn skalarny</h3>
<p>Iloczynem skalarnym dwóch wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> nazywany funkcję, która zwraca liczbę.</p>
<ul>
<li><span class="math inline">\(\braket{u}{v} = \braket{v}{u}^{\ast}\)</span></li>
<li><span class="math inline">\((\alpha \bra{u})\ket{v} = \alpha \braket{u}{v}\)</span></li>
<li><span class="math inline">\((\bra{u} + \bra{v}) \ket{z} = \braket{u}{z} +\braket{v}{z}\)</span></li>
<li><span class="math inline">\(\braket{u}{u} &gt; 0\)</span></li>
<li><span class="math inline">\(\braket{u}{u} = 0, gdy \ket{u}=\ket{0}\)</span></li>
</ul>
<p>Dla dwóch wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> otrzymujemy: <span class="math display">\[ \ket{u} = \begin{bmatrix} x_1 \\ x_2 \\ .\\ x_n \end{bmatrix}, \ket{v} = \begin{bmatrix} y_1 \\ y_2 \\ .\\ y_n \end{bmatrix} \]</span></p>
<p><span class="math display">\[ \braket{u}{v} = x_1^{*}y_1 +x_2^{*}y_2 + \dots + x_n^{*}y_n\]</span></p>
<blockquote class="blockquote">
<p>Zadanie - Udowodnij, że <span class="math inline">\(\braket{u}{u}\)</span> jest liczbą rzeczywistą.</p>
</blockquote>
<p><strong>wektor znormalizowany</strong> <span class="math inline">\(\braket{u}{u}=1\)</span></p>
<p><strong>wektory ortogonalne</strong> <span class="math inline">\(\braket{u}{v}=0\)</span></p>
</section>
<section id="kombinacja-liniowa-wektorów" class="level3">
<h3 class="anchored" data-anchor-id="kombinacja-liniowa-wektorów">Kombinacja liniowa wektorów</h3>
<p>Dla dwóch wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> oraz dwóch liczb <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> możemy stworzyć nowy wektor: <span class="math display">\[\ket{z} = \alpha \ket{u} + \beta \ket{v}\]</span> Wektor ten nazywamy kombinacją liniową wektorów <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> o współczynnikach <span class="math inline">\(\alpha\)</span> i <span class="math inline">\(\beta\)</span>.</p>
</section>
<section id="baza" class="level3">
<h3 class="anchored" data-anchor-id="baza">Baza</h3>
<p>Każda przestrzeń&nbsp;wektorowa ma <em>bazę</em>.</p>
<p><strong>Dowolny wektor można zapisa jako kombinację liniową wektorów bazowych.</strong></p>
<p>Interesowac będzie nas baza (obliczeniowa) dla której:</p>
<p><span class="math display">\[ \braket{e_i}{e_i}=1 \,\, \braket{e_i}{e_j}=0 \,\, \text{dla i} \neq j \]</span> gdzie <span class="math inline">\(i,\,j = 1,2,\dots, n\)</span>.</p>
<p>Dowolny wektor <span class="math inline">\(\ket{u}\)</span> możemy zapisa jako: <span class="math display">\[ \ket{u} = \braket{e_1}{u}\ket{e_1} + \braket{e_2}{u}\ket{e_2} + ... + \braket{e_n}{u}\ket{e_n}  \]</span></p>
<p>Warto zauważyc: <span class="math display">\[\braket{e_1}{u}= x_1\]</span> <span class="math display">\[\ket{u} = \sum_{i=1}^{n} \ket{i}\bra{i} \ket{u}\]</span></p>
</section>
</section>
<section id="formalizm-matematyczny-obliczeń-kwantowych" class="level2">
<h2 class="anchored" data-anchor-id="formalizm-matematyczny-obliczeń-kwantowych">Formalizm matematyczny obliczeń kwantowych</h2>
<p>Ta wiedza wystarczy do wyjaśnienia <em>notacji Diraca</em>.</p>
<p>Iloczyn skalarny <span class="math inline">\(\braket{\psi}{\phi}\)</span> wektorów <span class="math inline">\(\ket{\psi}\)</span> i <span class="math inline">\(\ket{\phi}\)</span> czytamy jako <em>braket u v</em>.</p>
<section id="stan" class="level3">
<h3 class="anchored" data-anchor-id="stan">Stan</h3>
<p>W fizyce klasycznej znajomość stanu układu oznacza, iż wiemy wszystko co jest potrzebne</p>
<p>Stanem w mechanice kwantowej nazywamy wektor:</p>
<p><span class="math display">\[\ket{\psi} = x_0 \ket{0} + x_1 \ket{1} + \dots x_{n-1} \ket{n-1}\]</span></p>
<p>Chcemy aby współczynniki <span class="math inline">\(x_i\)</span> były liczbami zespolonymi a cały wektor był unormowany do 1.</p>
<p>Liczby <span class="math inline">\(x_i\)</span> nazywamy <strong>amplitudami prawdopodobieństwa</strong> stanu kwantowego. Jeśli przynajmniej dwie liczby <span class="math inline">\(x_i\)</span> są niezerowe, to układ znajduje się w <strong>superpozycji</strong> stanów.</p>
</section>
<section id="kubit" class="level3">
<h3 class="anchored" data-anchor-id="kubit">Kubit</h3>
<p>Elementarnym obiektem w informatyce kwantowej jest <em>kubit</em>, który realizowany jest jako dwu wymiarowy układ kwantowy. Stan kwantowy kubitu opisuje <strong>wektor</strong> w przestrzeni liniowej <span class="math inline">\(\mathbb{C}^2\)</span>.</p>
<p>W celu wykonywania obliczeń i opisu stanu kubitu wybierzemy tzw. bazę obliczeniową: <span class="math display">\[\ket{0} = \begin{bmatrix} 1 \\ 0  \end{bmatrix} , \ket{1} = \begin{bmatrix} 0 \\ 1  \end{bmatrix}\]</span></p>
<p>To co wyróżnia kubit w porównaniu do klasycznego bitu dowolny stan <span class="math inline">\(\ket{\psi}\)</span> może być superpozycją stanów bazowych: <span class="math display">\[
\ket{\psi} = \alpha \ket{0} + \beta \ket{1} = \alpha \begin{bmatrix} 1 \\ 0\end{bmatrix} + \beta \begin{bmatrix} 0 \\ 1 \end{bmatrix} = \begin{bmatrix} \alpha \\ \beta \end{bmatrix}
\]</span> dla którego zachodzi warunek normalizacji: <span class="math display">\[
\braket{\psi}{\psi} = |\alpha|^2 + |\beta|^2 = 1
\]</span> gdzie <span class="math inline">\(\alpha, \beta \in \mathbb{C}\)</span>.</p>
<blockquote class="blockquote">
<p>ZADANIE - oblicz <span class="math inline">\(\braket{\psi}{\psi}\)</span>.</p>
</blockquote>
<p>Liczby <span class="math inline">\(\alpha\)</span> i <span class="math inline">\(\beta\)</span> nazywamy amplitudami prawdopodobieństwa. Są one reprezentowane przez liczby zespolone. Potrzeba 4 liczb rzeczywistych aby je opisać. Ze względu na warunek normalizacji jedną liczbę można obliczyc co oznacza potrzebę użycia już tylko trzech liczb rzeczywiste.</p>
<p>Stan kubitu możemy zapisać w postaci: <span class="math display">\[
\ket{\psi} = e^{i \gamma}\left( \cos{\frac{\phi}{2}} \ket{0} + e^{i \theta} \sin{\frac{\phi}{2}} \ket{1} \right)
\]</span> gdzie <span class="math inline">\(\phi \in [0, \pi]\)</span>, <span class="math inline">\(\theta \in [0, 2\pi]\)</span> i <span class="math inline">\(\gamma \in [0, 2\pi]\)</span> są liczbami rzeczywistymi.</p>
<p>Współczynnik <span class="math inline">\(e^{i \gamma}\)</span> nazywamy <em>fazą globalną</em>. Ze względu, iż analizować będziemy kwadraty amplitud prawdopodobieństwa to faza globalna nie ma znaczenia. Dlatego możemy napisać: <span class="math display">\[
\ket{\psi} = \cos{\frac{\phi}{2}} \ket{0} + e^{i \theta} \sin{\frac{\phi}{2}} \ket{1}
= \begin{bmatrix} \cos{\frac{\phi}{2}} \\ e^{i \theta} \sin{\frac{\phi}{2}} \end{bmatrix}
\]</span></p>
<p>Warto zauważyć, że dwa dowolne stany kubitów <span class="math inline">\(\ket{\psi}\)</span> i <span class="math inline">\(\ket{\phi}\)</span> różnią się o czynnik fazowy <span class="math inline">\(e^{i \gamma}\)</span> to stany te dają identyczne wyniki.</p>
<p>Liczby rzeczywiste <span class="math inline">\(\phi\)</span> i <span class="math inline">\(\theta\)</span> nazywamy <em>kątami</em> kubitu i możemy interpretować je jako współrzędne na <strong>sferze Blocha</strong>. Bardzo często będziemy wykorzystywać ją do wizualizacji stanów kubitów.</p>
<p>Stany w bazie obliczeniowej, którymi często będziemy operowac: <span class="math display">\[\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\]</span> <span class="math display">\[\ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})\]</span> <span class="math display">\[\ket{i} =\frac{1}{\sqrt{2}}(\ket{0} + i \ket{1})\]</span> <span class="math display">\[\ket{-i} =\frac{1}{\sqrt{2}}(\ket{0} - i \ket{1})\]</span></p>
<p>Lub: <span class="math display">\[\frac{1}{\sqrt{2}}(\ket{0} + e^{i\pi/6} \ket{1})\]</span> <span class="math display">\[\frac{\sqrt{3}}{2}(\ket{0} + \frac{1}{2} \ket{1})\]</span></p>
<blockquote class="blockquote">
<p>Kubit może by dowolnym punktem na sferze Blocha.</p>
</blockquote>
</section>
<section id="dwa-kubity" class="level3">
<h3 class="anchored" data-anchor-id="dwa-kubity">Dwa kubity</h3>
<p>Złączenie układu dwóch kubitów realizowane jest przez <em>iloczyn tensorowy</em> (iloczyn Kroneckera).</p>
<p>Rozważmy dwa stany kubitów <span class="math inline">\(\ket{\psi}\)</span>, <span class="math inline">\(\ket{\phi}\)</span></p>
<p><span class="math display">\[
\ket{\psi} = \alpha \ket{0} + \beta \ket{1} = \begin{bmatrix} \alpha \\ \beta \end{bmatrix}\, ,\,\,
\ket{\phi} = \gamma \ket{0} + \delta \ket{1} = \begin{bmatrix} \gamma \\ \delta \end{bmatrix}
\]</span></p>
<p>Stan dwukubitowy: <span class="math display">\[
\ket{\psi} \otimes \ket{\phi} = \begin{bmatrix} \alpha \gamma \\ \alpha \delta \\ \beta \gamma \\ \beta \delta \end{bmatrix} = \alpha \gamma \ket{0} \otimes \ket{0} + \beta \delta \ket{1} \otimes \ket{0}  + \alpha \delta \ket{0} \otimes \ket{1}  + \beta \delta \ket{1} \otimes \ket{1}
\]</span> co możemy zapisa jako: <span class="math display">\[
\ket{\psi \phi} = \alpha \gamma \ket{00} + \beta \delta \ket{10}  + \alpha \delta \ket{01}  + \beta \delta \ket{11}
\]</span> gdzie: <span class="math display">\[
\ket{00} = \begin{bmatrix} 1 \\ 0 \\ 0 \\ 0 \end{bmatrix}, \, \,
\ket{01} = \begin{bmatrix} 0 \\ 1 \\ 0 \\ 0 \end{bmatrix}, \, \,
\ket{10} = \begin{bmatrix} 0 \\ 0 \\ 1 \\ 0 \end{bmatrix}, \, \,
\ket{11} = \begin{bmatrix} 0 \\ 0 \\ 0 \\ 1 \end{bmatrix}
\]</span></p>
<p>Po przenumerowaniu stanów możemy napisac: <span class="math display">\[
\ket{\Phi} = c_0 \ket{0} + c_1 \ket{1}  + c_2 \ket{2}  + c_3 \ket{3}
\]</span> dla którego: <span class="math display">\[
|c_0|^2 + |c_1|^2 + |c_2|^2 + |c_3|^2 = 1
\]</span></p>
</section>
<section id="stan-separowalny-i-splątany" class="level3">
<h3 class="anchored" data-anchor-id="stan-separowalny-i-splątany">Stan separowalny i splątany</h3>
<p>Jeżeli istnieją stany <span class="math inline">\(\ket{\phi_1}\)</span> i <span class="math inline">\(\ket{\phi_2}\)</span> takie, że <span class="math display">\[\ket{\psi} = \ket{\phi_1} \otimes \ket{\phi_2}\]</span> to stan nazywamy <strong>separowalny</strong>.</p>
<p>Zobaczmy, czy istnieje przypadek w którym stan układu dwóch kubitów nie da się zaprezentowac jako iloczynu tensorowego podukładów. Aby to sprawdzic zobaczmy czy istnieją takie liczby <span class="math inline">\(c_0, c_1, c_2, c_3\)</span> dla których <strong>nie da się</strong> znaleźc <span class="math inline">\(\alpha, \beta,\gamma, \delta\)</span>, które spełniają układ równań: <span class="math display">\[c_0 = \alpha \gamma , \, c_1 = \alpha \delta , \, c_2 = \beta \gamma , \, c_3 = \beta \delta \]</span></p>
<p>Rozważmy stan <span class="math display">\[\ket{bell} = \frac{1}{\sqrt{2}}(\ket{0}+\ket{3}) = \frac{1}{\sqrt{2}}(\ket{00}+\ket{11})\]</span></p>
<p>Załóżmy, że możemy zapisa stan <code>bell</code> w postaci: <span class="math display">\[ \alpha \gamma \ket{0} + \beta \delta \ket{1}  + \alpha \delta \ket{2}  + \beta \delta \ket{3} \]</span></p>
<p>Aby stan <code>bell</code> był separowalny musi by spełniony układ równań:</p>
<p><span class="math display">\[\begin{eqnarray}
\alpha \gamma = \frac{1}{\sqrt{2}} \\ \alpha \delta = 0 \\ \beta \gamma = 0 \\ \beta \delta =\frac{1}{\sqrt{2}}
\end{eqnarray}\]</span></p>
<p>Z warunku drugiego mamy dwie możliwości: albo <span class="math inline">\(\alpha=0\)</span> lub <span class="math inline">\(\delta=0\)</span>. Jeżeli <span class="math inline">\(\alpha=0\)</span> to warunek pierwszy nie może byc spełniony. Jeżeli <span class="math inline">\(\delta=0\)</span> to warunek czwarty nie może byc spełniony. Otrzymujemy sprzecznośc.</p>
<p>Prowadzi to do wniosu, że stan <code>bell'a</code> nie jest stanem separowalnym i jest <strong>stanem splątanym</strong>. Stany te mają bardzo nieintuicyjne własności. Związany jest z nimi słynny paradox EPR oraz tak zwane nierówności Bella.</p>
<blockquote class="blockquote">
<p>Splątane stany Bell’a, wraz z zasadą superpozycji będą podstawowymi kwantowymi własnościami pozwalającymi zrealizowac przewagę obliczeń kwantowych nad obliczeniami klasycznymi.</p>
</blockquote>
</section>
</section>
<section id="pomiar-w-bazie-z" class="level2">
<h2 class="anchored" data-anchor-id="pomiar-w-bazie-z">Pomiar w bazie Z</h2>
<p>W opisie kubitów wybraliśmy specyficzą bazę (obliczeniową) wektorów, która rozkłada każdy wektor na kombinację wektora <span class="math inline">\(\ket{0}\)</span> i <span class="math inline">\(\ket{1}\)</span>.</p>
<p>Zasady przestrzeni wektorowej i mechaniki kwantowej dopuszczają tworzenie kombinacji liniowej (superpozycji) dla tych dwóch stanów. <span class="math display">\[
\ket{\psi} = \alpha \ket{0} + \beta \ket{1}
\]</span> Po pomiarze kubitu, czyli na końcu procesu obliczeniowego, ze względu na prawa fizyki otrzymujemy tylko i wyłącznie jeden ze stanów bazowych <span class="math inline">\(\ket{0}\)</span> lub <span class="math inline">\(\ket{1}\)</span>. Każdy następny pomiar (tej samej obserwabli) będzie kończyc się w tym samym (otrzymanym) stanie.</p>
<blockquote class="blockquote">
<p>Pomiar niszczy superpozycję kubitu i sprowadza go do jednego ze stanów bazowych.</p>
</blockquote>
<p>Dla kubitu w superpozycji stanów bazowych jedyne co możemy określic to prawdopodobieństwo otrzymania stanu <span class="math inline">\(\ket{0}\)</span> i <span class="math inline">\(\ket{1}\)</span>.</p>
<blockquote class="blockquote">
<p>Prawdopodobieństwo określone jest jako kwadrat (modułu) amplitudy Dla stanu <span class="math inline">\(\ket{0}\)</span> <span class="math inline">\(P(0) = |\alpha|^2\)</span> oraz dla stanu <span class="math inline">\(\ket{1}\)</span> <span class="math inline">\(P(1)= |\beta|^2\)</span>.</p>
</blockquote>
<p>Istnieje możliwośc pomiaru kubitów w innych bazach. Jednak w większości przypadków ograniczymy się do pomiaru w bazie obliczeniowej.</p>
<section id="przykład" class="level3">
<h3 class="anchored" data-anchor-id="przykład">Przykład</h3>
<p>Rozważmy stan <span class="math display">\[\ket{\psi} = \frac{\sqrt{3}}{2}\ket{0}+\frac{1}{2}\ket{1}\]</span></p>
<p>Możliwe wyniki pomiaru w bazie Z <span class="math inline">\(\{ \ket{0},\ket{1} \}\)</span>.</p>
<p><span class="math display">\[
\braket{0}{\psi} = \bra{0}\left( \frac{\sqrt{3}}{2}\ket{0} +\frac{1}{2}\ket{1}\right) = \frac{\sqrt{3}}{2}\braket{0}{0} + \frac{1}{2}\braket{0}{1} = \frac{\sqrt{3}}{2}
\]</span> Biorąc kwadrat apmlitudy otrzymujemy kubit w stanie <span class="math inline">\(\ket{0}\)</span> z prawdopodobieństwem <span class="math inline">\(0.75\)</span>. <span class="math display">\[
\braket{1}{\psi} = \bra{1}\left( \frac{\sqrt{3}}{2}\ket{0} +\frac{1}{2}\ket{1}\right) = \frac{\sqrt{3}}{2}\braket{1}{0} + \frac{1}{2}\braket{1}{1} = \frac{1}{2}
\]</span> Biorąc kwadrat apmlitudy otrzymujemy stan <span class="math inline">\(\ket{1}\)</span> z prawdopodobieństwem <span class="math inline">\(0.25\)</span>.</p>
<p><span class="math display">\[\ket{\psi} = \braket{0}{\psi}\ket{0} + \braket{1}{\psi}\ket{1}\]</span></p>
<p>Dowolna para liniowo niezależnych wektorów jednostkowych <span class="math inline">\(\ket{u}\)</span> i <span class="math inline">\(\ket{v}\)</span> pochodząca z dwuwymiarowej przestrzeni wektorowej może tworzyc bazę: <span class="math display">\[
\alpha \ket{0} +\beta \ket{1} = \alpha' \ket{u} +\beta' \ket{v}
\]</span> Przykładem może byc tzw Baza Hadamarda <span class="math inline">\(\ket{+}\)</span> i <span class="math inline">\(\ket{-}\)</span> zdefiniowana jako: <span class="math display">\[
\ket{+} = \frac{1}{\sqrt{2}}(\ket{0}+\ket{1}) = \begin{bmatrix} \frac{1}{\sqrt{2}} \\ \frac{1}{\sqrt{2}} \end{bmatrix}
\]</span> <span class="math display">\[
\ket{-} = \frac{1}{\sqrt{2}}(\ket{0}-\ket{1}) = \begin{bmatrix} \frac{1}{\sqrt{2}} \\ - \frac{1}{\sqrt{2}} \end{bmatrix}
\]</span></p>
<blockquote class="blockquote">
<p>Bardzo ważnym etapem jest wybór bazy w której dokonujemy pomiaru. np. dla wektora <span class="math inline">\(\ket{+}\)</span> pomiar w bazie standardowej pozwoli otrzymac wyniki stanu <span class="math inline">\(\ket{0}\)</span> i <span class="math inline">\(\ket{1}\)</span> z prawdopodobieństwami <span class="math inline">\(\frac{1}{2}\)</span>. Natomiast jeśli pomiar dokonywany byłby w bazie Hadamarda to zawsze otrzymamy stan <span class="math inline">\(\ket{+}\)</span> z prawdopodobieństwem 1.</p>
</blockquote>
</section>
</section>
<section id="kilka-ciekawostek-matematycznych" class="level2">
<h2 class="anchored" data-anchor-id="kilka-ciekawostek-matematycznych">Kilka ciekawostek matematycznych</h2>
<p>Stan kubitów, czyli dwuwymiarowych układów kwantowych, opisujemy wektorem <code>ket</code> <span class="math inline">\(\ket{a}\)</span>. Wektory te reprezentowane są jako <code>listy</code> zapisane w kolumnach. <span class="math display">\[ \ket{a} = \begin{bmatrix} a_0 \\ a_1 \end{bmatrix} \]</span></p>
<p>Oprócz wektorów <code>ket</code> wprowadziliśmy wektory <code>bra</code> powstające w wyniku operacji transpozycji i sprzęzenia zespolonego. Operacja ta jest bijekcją. <!-- // TODO sprawdzić i opisać to dokładniej. --></p>
<p>Przez bijekcję rozumiemy odwzorowanie bądź funkcję, która każdemu elementowi dziedziny przypisuje tylko jeden element przeciwdziedziny oraz dodatkowo cały zbiór dziedziny jest odwzorowany na przeciwdziedzinę. Zauważ, że druga własność jest potrzebna do zdefiniowania funkcji odwrotnej. Aby mówić o funkcji (odwrotnej), wszystkie elementy dziedziny (przeciwdziedziny) muszą zostać odwzorowane. Dzięki tej własności możemy zdefiniować całą przestrzeń dualną, w której podstawowymi składnikami są wektory dualne. Ponadto, wszystkie elementy przestrzeni wektorów bra mają swoje różne odpowiedniki w przestrzeni ketów i odwrotnie. To pozwala również stwierdzić, że tak naprawdę obie przestrzenie są izomorficzne, czyli takie same. Jedyną różnicą jest forma zapisu elementów. Operacja ta podobna jest do wpowadzenia wektorów dualnych na poziomie zakrzywionych rozmaitości rózniczkowalnych (ang. manifolds). W drugim przypadku definiujemy wektory kontrawariantne i kowariantne.</p>
<p>Wektory bra definiujemy jako listę wierszową. <span class="math display">\[ \bra{b} = \begin{bmatrix} a_0 \,\,\,  a_1 \end{bmatrix} \]</span></p>
<p>Do definicji przestrzeni wektorowej dodaliśmy definicję iloczynu skalarny. Zauważ, iz nie mówimy w tym przypadku o działaniu. Działania definiowały nam własności przestrzeni wektorowej. Wynikiem dodawania wektorów jak i mnożenia ich przez liczbę był zawsze jakiś wektor. A więc działania nie wyprowadzały nas poza przestrzeń wektorową. W przypadku iloczynu skalarnego wybieramy wektor oraz drugi wektor dualny. Po złozeniu jednego i drugiego otrzymujemy liczbę (skalar). <span class="math display">\[ \braket{a}{b} \]</span></p>
<p>Do jego wprowadenia wymagane było wprowadzenie przestrzeni dualnej.</p>
<p>Korzystając z wektorów bra i ket możemy zdefiniować jeszcze jedną operacje.</p>
<p><span class="math display">\[ \ket{a} \bra{b} \]</span> Tym razem to co otrzymujemy mozemy traktować jako operator.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>